= 26. A (Pretty Deep Dive) Introduction to Next.js
:icons: font
:toc: left

link:udemy_react.html[<Contents>]

====
Getting Started with Next.js::
https://nextjs.org/docs/app/getting-started/installation

v0::
https://v0.dev/
====

=== 426. Module Introduction

This section of the course introduces building a new React project with a focus on creating a fullstack application using NextJS, a React framework. The project allows users to view and share meals within a foodies community. Unlike previous lessons, this project combines both front-end and backend elements. You'll learn about NextJS, its benefits, and how to set up routes, pages, and work with React components within this framework. The section will cover data fetching and sending, styling, working with images, and page metadata, enhancing your React skills to create fullstack applications.

=== 427. Creating a NextJS Project

The content explains how to set up a new Next.js project, highlighting the differences from standard React projects. It suggests using the command `npx create-next-app` to create a project with Next.js pre-installed and outlines the initial setup process, including optional configurations like TypeScript, ESLint, and Tailwind CSS. The instructor opts out of using TypeScript and Tailwind to simplify the course content. After the project is created, they replace some default files with customized ones and provide a starting snapshot for learners to use, either through local files or CodeSandbox. Finally, they guide users on running the project using `npm run dev` to start the development server, noting that CodeSandbox automates this process.

```
npm run dev
```

=== 428. Understanding File-based Routing & React Server Components

The text explains the role of the `app` folder in a modern NextJS project, particularly focusing on the `Page.js` file within it. The `Page.js` file is important because it designates a React component as a page in NextJS, and it functions as a server component. This means the component is executed on the server, not the client side, which is a unique feature of NextJS compared to traditional React. Logs from the component are visible in the server terminal, not the browser console, demonstrating its server-side execution. The server component's JSX code is then sent to the client's browser to be rendered as HTML, making it visible on the screen.

=== 429. Adding Another Route via the Filesystem

The document explains how to add a new page to a Next.js website using server components. In Next.js, rather than using React Router, you create new pages by adding folders with a `page.js` file inside the `app` directory. For example, to create a page accessible at `localhost:3000/about`, you would create an `about` folder in the `app` directory and include a `page.js` file within it. This file should export a function returning the JSX content that will be rendered on the page. The folder structure is crucial because Next.js uses it to define routes. Once set up, visiting the `/about` route will display the content specified in the `about` page's component.

=== 430. Navigating Between Pages

The provided text explains how to enhance navigation between pages in a NextJS application without losing the single-page application (SPA) benefits. Initially, a traditional anchor element is used to link to a new page, causing a full page reload and breaking the SPA model by downloading a new page from the backend. To maintain the SPA experience, the text suggests using the `Link` component from `next/link`, which allows navigation without fully reloading the page. This component ensures that while the content is pre-rendered on the server, it updates on the client side with JavaScript, providing a seamless, interactive user experience.

=== 431. Working with Pages & Layouts

The provided content explains the structure and purpose of layout and page JS files in a Next.js project. The page JS file defines the content of a specific page, while the layout JS file acts as a shell or wrapper for one or more pages. A root layout JS file is necessary at the top of the app folder, and additional nested layout files can be added for specific sections like an "about" folder. The layout file exports a React component that uses the children prop to render page content between HTML and body tags, setting up the basic HTML skeleton. The head element, typically used for metadata like titles, is not included directly in layout files because Next.js allows metadata to be set via a special reserved variable called "metadata." This way, the metadata applies to all pages covered by the layout. The children prop represents the content of the currently active page, illustrating how layout and page JS files work together, with layout providing the structure and page offering the content.


=== 432. Reserved File Names, Custom Components & How To Organize A NextJS Project

The provided text explains the setup and organization of a NextJS project, focusing on file structure and component management. It highlights the use of a `globals.css` file for global styles across all pages by importing it in `layout.js`, and mentions the special `icon.png` file for setting a favicon without explicit configuration in `layout.js`. The text describes creating routes through folders and reserved filenames like `page.js` and `layout.js`, and discusses adding regular React components that aren't automatically treated as pages. It suggests organizing components in a `components` folder, either inside or outside the `app` directory, and emphasizes the importance of `page.js` for routing. Additionally, it mentions using an `@` symbol in import paths for convenience, as configured in a `jsconfig` file, to simplify imports by referencing the root project folder. The text recommends consulting the official NextJS documentation for structuring projects and concludes with a preference for keeping components outside the `app` folder for a cleaner routing-focused structure.

=== 433. Reserved Filenames

In NextJS, certain filenames are reserved when used inside the `app/` folder (or any subfolders). These reserved filenames include:

- `page.js`: Creates a new page (e.g., `app/about/page.js` for `<your-domain>/about`).
- `layout.js`: Sets up a layout wrapping sibling and nested pages.
- `not-found.js`: Serves as a fallback for "Not Found" errors.
- `error.js`: Acts as a fallback for other errors.
- `loading.js`: Displays while sibling or nested pages (or layouts) are fetching data.
- `route.js`: Creates an API route, returning data instead of JSX (e.g., JSON format).

These filenames have specific purposes and are only treated specially within the `app/` folder. For more details, refer to the official documentation.

=== 434. Configuring Dynamic Routes & Using Route Parameters

The text provides a detailed explanation of setting up dynamic routes in a NextJS application, particularly for a blog with multiple posts. It describes the process of creating a scalable and maintainable routing structure, emphasizing the use of dynamic routes to handle multiple posts without manually creating a new folder for each post. This is achieved using a special syntax in NextJS, where square brackets are used to create a placeholder (e.g., `[slug]`) for dynamic segments in the URL. This allows the same page component to render different content based on the URL path segment values. The text also explains how NextJS automatically passes a `params` prop containing these dynamic segment values, which can be used to fetch specific content like blog posts from a database. The explanation hints at further capabilities of NextJS, such as custom error handling and data fetching, which will be explored in a future project focused on a Meals app.

=== 435. Onwards to the Main Project - The Foodies App

The text describes a new project, a foodies app, which is set up in both local and CodeSandbox versions. The project has been simplified by removing previously created pages and includes a new assets folder with necessary images. Updates have been made to styles, and the layout and page JavaScript files. Notably, the layout JavaScript file now includes an SVG graphic for aesthetic purposes, to be displayed behind the website's header. This project is prepared and ready for further work.

=== 438. Revisiting The Concept Of Layouts

The content provides a detailed explanation of how layouts function in NextJS, particularly focusing on creating and utilizing a root layout and nested layouts. The author intends to enhance a webpage by adding a proper header, navigation, and logo using the `layout.js` file. In NextJS, layouts serve as wrappers around pages and can be nested for more specialized layouts. The root layout remains active across all pages, while nested layouts apply only to specific subsets, like meals-related pages in this example. The explanation includes using React components and the `children` prop to manage content within layouts. Although a nested layout was demonstrated, it was deemed unnecessary for the current task, so the focus shifted to updating the root layout to include a universal header for navigation.

=== 439. Adding a Custom Component To A Layout

The text describes the process of creating a new header component in a Next.js project. The author explains the steps for adding a "MainHeader" component to manage a shared header across all pages. This involves creating a separate file named `main-header.js` and exporting a React component called `MainHeader`. The component includes a clickable logo, using Next.js's `Link` component, and a navigation menu with links to different pages. The author emphasizes the flexibility in organizing component files and chooses to keep them outside the app folder for clarity. They also mention importing images in Next.js projects, highlighting the need to access the `src` property. Finally, the component is integrated into the root layout, and although the header is functional, it requires styling to improve its appearance.

=== 440. Styling NextJS Project - Your Options & Using CSS Modules

The provided text explains various methods for styling NextJS projects, focusing on CSS options. Initially, it discusses using global CSS files, which apply styles across all pages when imported into the root `layout.js` file. Another popular option is Tailwind CSS, a utility-first CSS framework that allows styling through small utility classes; however, it's not used in this project to keep the focus on NextJS and React. Instead, CSS modules are chosen, offering a way to scope styles to specific components by using files ending in `.module.css`. These modules prevent styles from affecting other components, even with similar class names. The process involves importing these CSS module files into component files and using the imported object to access and apply the styles. The text concludes by demonstrating how this method results in a well-styled header, logo, and navigation links in the project.

=== 441. Optimizing Images with the NextJS Image Component

The content discusses optimizing image handling in a NextJS project by using the built-in NextJS image component instead of the default HTML image element. The NextJS image component provides several benefits, such as lazy loading, responsive image setup, automatic size detection, and serving images in optimal formats like WebP for different browsers. It simplifies image management without additional configuration. The component also allows customization, such as prioritizing image loading to prevent content shift during page load. The text encourages exploring further options and configurations for advanced use cases, like loading images from third-party sources.

=== 442. Using More Custom Components

The text describes the process of refactoring a web application's header background into a separate component for better organization and practice. The steps include creating a new JavaScript file (`main-header-background.js`) for the component, extracting the relevant HTML and CSS into separate module files, and adjusting the CSS to work with modules. The component is then integrated back into the application within `main-header.js` instead of `layout.js`, and all related files are organized into a `main-header` subfolder within the `components` directory. Path updates are also made to ensure the application functions as expected. This organization improves code maintainability and clarity.

=== 443. Populating The Starting Page Content

The content describes the process of updating the main page content in a `page.js` file located in the root of the app folder. The aim is to replace existing content with a new layout that includes a page-specific header and main section. The header will contain a nested header introducing the page, a `div` for an image slideshow, and another `div` with two inner `divs` for a hero section and a call-to-action (CTA) section. The hero section will have an `h1` title and a marketing paragraph, while the CTA section will contain links for users to join a community and explore meals. CSS modules are used for styling, and the file includes a `page.module.css` for this purpose. The main section will temporarily hold dummy text. The description also notes that a prepared `page.js` file is available for use, and the next step will be to work on the image slideshow.

=== 444. Preparing an Image Slideshow

The statement discusses the process of adding an image slideshow to a web project using React and Next.js. The plan is to create a new component for the slideshow to keep the main file lean. This component will be placed in a new subfolder within the components folder, specifically named `image-slideshow.js`, along with a CSS module file for styling.

The JavaScript file will use React's `useState` and `useEffect` hooks to manage the slideshow's state, changing the visible image every five seconds using `setInterval`. The images are imported from an assets folder and displayed using Next.js's image component.

However, while attempting to integrate this component into the main page, an error occurs. The error indicates a conflict between client and server components in Next.js because the slideshow component requires `useState` (a client-side feature) but is being used within a server component context. This highlights the need to mark components correctly in Next.js to handle client-side functionality.

=== 445. React Server Components vs Client Components - When To Use What

The text explains the distinction between Server and Client components in NextJS, a full-stack framework built on React. Unlike standard React applications that run purely on the client side, NextJS utilizes Server components that are rendered on the server before being sent to the client. This approach can enhance performance and improve search engine optimization by delivering complete HTML content to web crawlers. However, Client components, necessary for features like state management and event handling, are also supported in NextJS. They must be explicitly defined using the `use client` directive, enabling client-side features such as hooks and event handlers. Understanding these component types is crucial for effectively leveraging NextJS's capabilities.

=== 446. Using Client Components Efficiently

The provided text details the process of updating a community page and improving navigation functionality within a project using NextJS. First, the community page is populated with dummy content by replacing existing files with attached `page.js` and `page.module.css` files. A `community` component is used to display placeholder text and images. The main focus of the project will be on meal-related logic, which will be addressed later.

The navigation header is improved by highlighting the active page link. This is achieved by adding a CSS class conditionally based on the current path. The `usePathname` hook from NextJS is used to determine the active path. A new `NavLink` component is created to handle the active link logic, ensuring only necessary parts are rendered as client components. This keeps the majority of the components as server components, maintaining server-side rendering advantages. CSS classes are adjusted and imported to style the links properly. By segmenting client-side rendering to specific components, the project maintains optimal performance while enhancing navigation user experience.

=== 447. Outputting Meals Data & Images With Unknown Dimensions

The content outlines a development plan for a Meals page in a web application. Initially, the team has worked on the starting and community pages, as well as the header. The focus is now on the Meals page, which will eventually allow users to share meals. The task involves setting up the page structure with a header and main section, and importing necessary styles from a CSS module. The header includes a title, a paragraph, and a link to a share page for users to contribute recipes.

A new component, `MealsGrid`, is introduced to display meal items in a grid format. This component will map through meal data, outputting each meal as a list item with a unique key (`meal.id`). Styles for this component are managed via a CSS module. Another component, `MealItem`, is created to display details of each meal, including dynamic links to meal detail pages and images. The images, stored in a database, will use the Next.js Image component with a `fill` prop to handle dynamic dimensions since their sizes are unknown at build time.

The `MealsGrid` component is integrated into the Meals page, though initially, it displays no meals due to the absence of a data source. Future steps will involve populating this component with actual meal data.

=== 448. Setting Up A SQLite Database

The process described involves setting up a local SQLite database to store meal data for a meals grid component in a development environment. Here's a summary:

1. **Purpose**: To display meals on a screen, a database is needed to store meal information, including dummy data and user-shared meals.

2. **Setup**:
   - Stop the development server using `Ctrl + C`.
   - Install the `better-sqlite3` package using `NPM install`. This package allows interaction with a SQLite database, which is chosen for its simplicity and local setup.

3. **Database Initialization**:
   - An `initdb.js` file is prepared to create and initialize the database with dummy meal data.
   - The file creates a new database or uses an existing one and sets up a table with fields like ID, slug, title, image path, summary, instructions, creator's name, and email.

4. **Data Insertion**:
   - The `initdb.js` file uses the installed package to execute a function that populates the database with dummy meal entries.
   - The `prepare` function from `better-sqlite3` is used for this purpose.

5. **Execution**:
   - Run the `initdb.js` script using `node` to generate the `meals DB` file.
   - This database will then be used to load meals onto the meals page.

The next step involves figuring out how to load meals from this database onto the meals page.

=== 449. Fetching Data By Leveraging NextJS & Fullstack Capabilities

The content discusses data loading in a Next.js application, highlighting its server-side capabilities. Unlike vanilla React, Next.js combines backend and frontend, allowing direct database access without useEffect or fetch requests. The example involves setting up a database connection using the better SQLite3 package and creating a function to fetch data from a database. The explanation includes converting functions to async for handling promises and simulating delays, which is beneficial for managing loading states. It also covers passing data to components without `useEffect`. A minor styling error is noted, and the document concludes with an overview of how data and images are fetched and displayed in the application.

=== 450. Adding A Loading Page

The content discusses how to improve user experience when loading pages in a web application using NextJS. Initially, when accessing a meals page, there's a noticeable delay due to a forced two-second wait implemented in the data fetching function. However, NextJS caches pages, so revisiting them is faster. To enhance the experience during the initial load, a loading indicator can be added. This is achieved by creating a `loading.js` file, which displays a message (e.g., "Fetching meals...") while data is being loaded. This provides immediate feedback to users, indicating that their navigation request is processing, thus improving the overall user experience. Basic styling for this indicator is handled with a `loading.module.css` file.

=== 451. Using Suspense & Streamed Responses For Granular Loading State Management

The text discusses improving the user experience on a NextJS meals page by handling loading states more effectively. Initially, the loading text occupies the entire screen, which is not ideal since the header can be displayed immediately without waiting for data. The proposed solution involves using React's `Suspense` component to manage loading states. By moving data fetching to a separate component and wrapping it with `Suspense`, it allows displaying fallback content while data loads. This approach avoids using the `loading.js` file that applies to all nested layouts, enabling more granular control. The text also explains how this method partially renders the page, loading visible content first and streaming in data as it becomes available, enhancing the user experience.




