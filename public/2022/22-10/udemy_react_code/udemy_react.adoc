= React - The Complete Guide (incl Hooks, React Router, Redux)
:source-highlighter: coderay
:icons: font
:toc: left
:toclevels: 4
Maximilian Schwarzmüller

====
Course on Udemy::
https://www.udemy.com/course/react-the-complete-guide-incl-redux/

Course source code on GitHub::
https://github.com/academind/react-complete-guide-course-resources
====

== 1. link:getting_started.html[Getting Started]

== 2. link:js_refresh.html[JavaScript Refresher]

== 3. link:react_basics.html[React Basics and Working With Components]

== 4. React Essentials - Deep Dive

=== 60. Module Introduction

In this course section, we will delve deeper into key React concepts covered previously. We will examine JSX and non-JSX code, revisit Components and State for better structure, and explore advanced state usage, patterns, and best practices. We'll start by enhancing the demo application from the last section, and later, we'll build a tic-tac-toe game to explore advanced concepts.

=== 61. You Don't Have To Use JSX!

This section discusses JSX code in React, emphasizing that while JSX is a non-standard feature not directly supported by browsers, it simplifies the development process. JSX code is transformed by a build process into browser-compatible code. Although it's possible to create React applications without JSX using the `createElement` method from React, this approach is more verbose and less intuitive. Most React projects, including those in this course, will utilize JSX for its convenience and readability. The text also highlights that using the non-JSX method requires no build process but is typically more complex. A practical example is provided, demonstrating how to create a root component using both JSX and the non-JSX approach while achieving the same result on screen.

=== 62. Working with Fragments

The discussion focuses on JSX and its requirement for a single parent element in a return statement. In an example using a `div` to wrap sibling elements, it is explained that removing the `div` leads to an error because JSX must return one parent element. This limitation is likened to JavaScript's inability to return multiple values from a function. To avoid unnecessary DOM elements, React provides a `Fragment` component, which can be used as a wrapper without rendering an actual element. Additionally, modern React projects allow for an even shorter syntax using empty tags to achieve the same effect without extra code or DOM elements.

====
Working with Fragments::
++++
<a href="https://github.com/academind/react-complete-guide-course-resources/blob/main/code/04%20Essentials%20Deep%20Dive/02-fragments/src/App.jsx" target="_blank">
04 Essentials Deep Dive/02-fragments</a>
++++
====

=== 63. When Should You Split Components

The discussion focuses on the challenges of managing a large React component, specifically the `App` component, which has multiple responsibilities such as rendering core concepts, managing tap buttons, and handling interactive states. The current structure leads to inefficiencies, as state updates cause unnecessary re-executions of the header component, resulting in unintended behavior like generating a new random number each time. This indicates the need to split the app component into smaller, more focused sub-components to better manage responsibilities and improve performance, a crucial skill for React developers.

=== 64. Splitting Components By Feature & State

The text discusses breaking down a large React App Component into smaller, more manageable components, which is a common best practice in React development. The process involves creating two new components: `CoreConcepts` and `Examples`. 

1. **Core Concepts Component**: 
   - The relevant section of the App Component is cut out and pasted into a new `CoreConcepts.jsx` file.
   - The component imports necessary data and exports a function that returns the JSX for Core Concepts.

2. **Examples Component**: 
   - Similarly, the section for examples, including tab buttons and content, is transferred to a new `Examples.jsx` file.
   - This component also handles its own state and imports necessary data and React hooks.

3. **App Component Adjustments**: 
   - The App Component is cleaned up by removing imports related to the now-extracted features and importing the new components instead.
   - The state management for the tab content is moved to the Examples Component, which affects how the application behaves when tabs are clicked.

The overall goal is to create a leaner App Component by distributing features across smaller components, making the codebase easier to manage, especially in larger projects. After these changes, the application should function identically to before, without errors, while now having a more organized structure.

====
Splitting Components::
++++
<a href="https://github.com/academind/react-complete-guide-course-resources/blob/main/code/04%20Essentials%20Deep%20Dive/03-splitting-components/src/App.jsx" target="_blank">
04 Essentials Deep Dive/03-splitting-components</a>
++++
====

=== 65. Problem - Props Are Not Forwarded To Inner Elements

In this section, the focus is on enhancing an existing React application by creating a reusable `Section` component. The idea is to maintain a consistent structure for sections in the application, which typically includes a title and content. The `Section` component will accept `props`, specifically a `title` and `children`, allowing for dynamic content rendering.

The process involves:

1. Creating a `section.jsx` file in the components folder.
2. Defining the `Section` component to return a section element with an `h2` title and the content passed through `children`.
3. Importing and using the `Section` component in the `examples.jsx` file, replacing existing section markup with the new component.

However, an issue arises with styling because when props are set on a custom component, they are not automatically forwarded to the underlying HTML elements. This results in lost styling, as the `ID` prop set on the `Section` component was not passed to the actual section element.

To resolve this, it's suggested to destructure and manually pass props like `ID` and `className` to the built-in section element. However, this approach can become cumbersome with multiple attributes. A more scalable solution involves using a pattern known as "forwarding props," which allows for easier management of attributes without needing to manually destructure each one.

=== 66. Forwarding Props To Wrapped Elements

The passage explains how to use JavaScript's destructuring and spread syntax when creating custom components in React. By using the spread operator (three dots), developers can collect all additional props passed to a component and merge them into a `props` object. This allows for forwarding those props to built-in elements, maintaining flexibility in the component's usage without manually extracting each prop.

The example specifically discusses a `Section` component that utilizes this pattern to forward various props like ID and class name to a built-in `Section` element. It highlights the benefits of this approach in creating wrapper components, ensuring they remain functional and flexible. The same technique can be applied to other components, such as `TabButton`, by spreading any remaining props onto a built-in button and replacing custom props with standard ones (e.g., replacing `onSelect` with `onClick`). This maintains the original functionality while simplifying prop management in the components.

====
Forwarding Props::
++++
<a href="https://github.com/academind/react-complete-guide-course-resources/blob/main/code/04%20Essentials%20Deep%20Dive/04-forwarding-props/src/components/Section.jsx" target="_blank">
04 Essentials Deep Dive/04-forwarding-props</a>
++++
====

=== 67. Working with Multiple JSX Slots

The section discusses the creation of a reusable tabs component in a React project, emphasizing the props forwarding pattern. The current setup for tabs consists of a menu bar with buttons and content displayed below, which may work for simple applications but could become cumbersome in larger ones. 

To improve reusability, a new `Tabs` component is proposed, allowing the use of prop destructuring to manage dynamic tab content. The author suggests managing tab button clicks and content outside the `Tabs` component to maintain its status as a "dumb" wrapper. 

To accomplish this, an additional prop (e.g., `buttons`) is introduced to allow passing tab buttons as JSX, alongside a `children` prop for content. This enables the `Tabs` component to have a clear structure: buttons inside a menu element and content below it. The example demonstrates how to implement this pattern, which, although seemingly redundant for simple applications, is essential for scalable React development.

====
Multiple JSX Slots::
++++
<a href="https://github.com/academind/react-complete-guide-course-resources/blob/main/code/04%20Essentials%20Deep%20Dive/05-multiple-jsx-slots/src/components/Tabs.jsx" target="_blank">
04 Essentials Deep Dive/05-multiple-jsx-slots</a>
++++
====

=== 68. Setting Component Types Dynamically

The discussion focuses on enhancing a Tabs component by allowing it to accept a `buttonsContainer` prop that determines the wrapper element for buttons within the component. This approach aims to improve flexibility, enabling developers to choose different wrapper elements (like `menu`, `ul`, `div`, or custom components) when using the Tabs component in various parts of an application.

To implement this, the idea is to create a variable that starts with a capital letter (e.g., `ButtonsContainer`) to reference the `buttonsContainer` prop within the component. This allows React to treat the prop's value correctly, whether it's a built-in HTML element or a custom component. 

Key points to remember include:

- Built-in elements should be passed as string identifiers (e.g., "menu").
- Custom components should be passed as identifiers without angle brackets, and they must start with an uppercase character to be recognized as components.

This pattern enhances the reusability of the Tabs component while maintaining a clean separation between buttons and content.

====
Setting Component Types Dynamically::
++++
<a href="https://github.com/academind/react-complete-guide-course-resources/blob/main/code/04%20Essentials%20Deep%20Dive/06-dynamic-component-types/src/components/Tabs.jsx" target="_blank">
04 Essentials Deep Dive/06-dynamic-component-types</a>
++++
====

=== 69. Setting Default Prop Values

The discussion focuses on the concept of default prop values in React, specifically using the Tabs component. The ButtonsContainer prop, which designates a wrapper for buttons, is highlighted as an example where a default value can enhance usability. By utilizing destructuring syntax in the component definition, a default value (such as "menu") can be assigned to the `ButtonsContainer` prop. This allows the Tabs component to function without explicitly setting the ButtonsContainer, thereby simplifying its usage while maintaining the same functionality. The example demonstrates that even without specifying the prop, the Tabs component defaults to using the menu element as the wrapper.

=== Coding Exercise 15: Creating Flexible Components

```
export default function Button({ children, mode="filled", Icon, ...props }) {
    const noIconClass = `button ${mode}-button`;
    const withIconClass = noIconClass + " icon-button";
    return (
        <button className={Icon ? withIconClass : noIconClass} {...props}>
            {
                Icon ?
                <span className="button-icon"><Icon /></span> :
                ''
            }
            <span>{children}</span>
        </button>
    )
}
```

=== 70. Onwards To The Next Project & Advanced Concepts

The section discusses the initial setup for a tic-tac-toe game using React. It begins by explaining the intention to create a header with an image and title. Instead of adding this directly to the app component in `App.jsx`, the author decides to place a simple "coming soon" paragraph there and moves the header markup to the `index.html` file, which is served to visitors. This approach is justified because the header is static and does not rely on React's props or state. The author highlights that static content can be directly added to `index.html`, while dynamic content should be managed within React components. Additionally, the project includes a public folder for images, and the author demonstrates how to reference an image from this folder in `index.html`. The alt text for the image is specified, and the section concludes by indicating readiness to proceed with developing the game logic in the React components.

=== 71. Not All Content Must Go Into Components

The discussion focuses on building a tic-tac-toe game and highlights the importance of understanding various patterns and concepts during development. The initial step involves adding a header to the application that consists of an image and a title. Instead of placing this header directly into the main React component (`App.jsx`), the author suggests adding static markup directly into the index.html file, which serves the initial HTML to website visitors. This is emphasized as a valid approach for static content that doesn't depend on React's state or props.

The author explains how to reference images stored in the public folder without needing to define a path, as these files are served alongside the index.html. The example given refers to an image named "game-logo.png" with appropriate alt text. After implementing these changes, the header should display correctly when the application is reloaded. Finally, the author indicates a transition to working on the React components to develop the game logic.

====
Static Content::
++++
<a href="https://github.com/academind/react-complete-guide-course-resources/blob/main/code/04%20Essentials%20Deep%20Dive/07-tic-tac-toe-starting-project/index.html" target="_blank">
04 Essentials Deep Dive/07-tic-tac-toe-starting-project</a>
++++
====

=== 72. Closer Look - public vs assets for Image Storage

The document explains the use of two folders in a web development project: `public/` and `src/assets/`.

- **public/ Folder**: Files stored here, such as images, are publicly accessible and can be directly referenced in `index.html` or `index.css`. They can be accessed via a browser, for example, through `localhost:5173/some-image.jpg`.

- **src/assets/ Folder**: Files in this folder are not publicly accessible and cannot be directly loaded by website visitors. Instead, they are used in code files, where they are processed and optimized by the build system before being made available in the `public/` folder.

**Usage Guidelines**:

- Use the `public/` folder for files that should be publicly available and not processed by the build system (e.g., favicons).
- Use the `src/` folder for images needed within components, as these will be handled by the build process.

=== 73. New Project - First Steps Towards Our Tic-Tac-Toe Game

The task involves developing a main game component for a tic-tac-toe web application. The component will include three primary building blocks: a player name display and editing area, a game board, and a log for tracking player turns. 

To start, the developer will create a main wrapper element and a "game container" div for organizing the layout. Inside the container, an ordered list will be used to display the players' names and symbols (X for player one and O for player two). Each player's name will be wrapped in a span with the class "player name," while their symbol will be in another span with the class "player symbol." 

Currently, the player names are hard-coded, but the developer plans to make them dynamic and add functionality for editing the names in the future. Once the basic structure is set up, the next step will be to implement the editing feature.

=== 74. Concept Repetition - Splitting Components & Building Reusable Components

The passage discusses the process of enhancing a React application by adding an "Edit" button next to player names and symbols. It highlights the need to avoid repeating markup for players in the App component, suggesting the creation of a separate Player component to encapsulate the repeated structure. This involves creating a components folder and a Player.jsx file, where the Player component accepts props for the player’s name and symbol. The existing repeated markup is moved to this new component, streamlining the code by allowing for the use of props to render player-specific data. The final step involves importing and utilizing the Player component in the App component, thereby improving code organization while setting the stage for future functionality of the Edit button.

=== 75. Concept Repetition - Working with State

The task involves implementing an edit feature for a player's name in a React component. When the "Edit" button is clicked, it should display an input field for the user to update the player's name, replacing the displayed name. The button should also change its label to "Save" while in edit mode. 

To achieve this, you'll need to manage a state using `useState` to track whether the component is in editing mode (a Boolean value). Initially, the state is set to `false`. A function named `handleEditClick` is created to set the editing state to `true` when the button is clicked. 

Next, conditional rendering is implemented: if the editing state is `false`, the player's name is displayed; if `true`, an input field appears. The input field should be set to accept text and will be enhanced further later to allow saving the changes and pre-populating it with the current player's name. Overall, this implementation allows for basic interactivity in the player component.

====
Working with State::
++++
<a href="https://github.com/academind/react-complete-guide-course-resources/blob/main/code/04%20Essentials%20Deep%20Dive/08-working-with-state/src/components/Player.jsx" target="_blank">
04 Essentials Deep Dive/08-working-with-state</a>
++++
====

=== 76. Component Instances Work In Isolation!

The speaker emphasizes an important feature of React: component isolation. When reusing components, such as the player component in the application, each instance functions independently. Changes in one instance do not affect others, allowing for complex, reusable components that do not interfere with each other. This isolation is crucial for maintaining the integrity of individual components, ensuring that actions like editing only impact the intended instance.

=== 77. Conditional Content & A Suboptimal Way Of Updating State

The task involves modifying a user interface to toggle between an editable input field and displaying the player's name. The edit button's label should change between "Edit" and "Save" based on whether the input field is active or not. 

To implement this:

1. **Button Caption**: Introduce a dynamic value for the button caption using a variable (`btnCaption`) or a ternary expression based on the `isEditing` state. Default to "Edit" and change to "Save" when editing.
  
2. **Pre-Populate Input**: Set the value of the input field to the current player's name using the `name` prop to ensure it reflects the correct player's name.

3. **Toggle Edit Mode**: Modify the `handleEditClick` function to toggle the `isEditing` state. Instead of using a ternary expression to switch the state, a simpler approach is to use the negation operator (`!`), which inverts the current state.

By implementing these changes, the interface will allow users to edit player names and toggle between edit and display modes effectively.

=== 78. Best Practice - Updating State Based On Old State Correctly

In React, when updating state based on its previous value, it is recommended to use a functional approach by passing a function to the state updater (e.g., `setIsEditing`). This method ensures that React provides the most current state value when executing the update, preventing potential issues with asynchronous state updates. 

Using the functional approach guarantees that each state update reflects the latest state, as opposed to using the current state directly, which may lead to unexpected behavior when multiple updates are scheduled in quick succession. It is essential for React developers to adopt this best practice to ensure reliable and accurate state management in their components.

====
Updating State Based On Old State::
++++
<a href="https://github.com/academind/react-complete-guide-course-resources/blob/main/code/04%20Essentials%20Deep%20Dive/09-updating-state-based-on-old-state/src/components/Player.jsx" target="_blank">
04 Essentials Deep Dive/09-updating-state-based-on-old-state</a>
++++
====

=== 79. User Input & Two-Way-Binding

The passage discusses how to enable editing of a player name in a React component. Initially, the input field does not allow editing because the value prop is set, which prevents user input from being reflected. The author suggests using a default value prop instead, but this doesn't save changes. Instead, a better approach is to use the `useState` hook to manage the player name as a piece of state, allowing the component to update and reflect changes.

The following steps are outlined:

1. Introduce a new state variable for the player name.
2. Rename the variable to avoid conflicts and set its initial value from a prop.
3. Create a `handleChange` function to update the state when the user types in the input field.
4. Attach the `handleChange` function to the input's `onChange` event to capture user input.

By doing this, both the input field and the displayed player name will update correctly, allowing for two-way binding where the input reflects changes made by the user. The author concludes by explaining that this method allows the component to manage user input effectively, ensuring updated values are saved and displayed correctly.

====
Two-Way-Binding::
++++
<a href="https://github.com/academind/react-complete-guide-course-resources/blob/main/code/04%20Essentials%20Deep%20Dive/10-two-way-binding/src/components/Player.jsx" target="_blank">
04 Essentials Deep Dive/10-two-way-binding</a>
++++
====

=== 80. Rendering Multi-Dimensional Lists

The player functionality for a tic-tac-toe game has been completed, allowing for name editing, and the next step is to create the game board. This involves developing a `GameBoard` component that displays a three-by-three grid using a list structure populated with buttons. Instead of hardcoding the grid, an `initialGameBoard` constant is defined as an array of arrays, initially filled with `null` values. This setup allows for dynamic updates when players click on squares.

The grid is rendered using the `map` method to iterate over the rows and columns, creating list items for each square. Each button will either display an 'X', an 'O', or nothing based on player interactions, though the logic for updating the state on clicks is not yet implemented. The `GameBoard` component is then integrated into the main app component, resulting in a visible grid with clickable buttons, setting the stage for the next phase of adding game logic.

====
Multi-Dimensional Lists::
++++
<a href="https://github.com/academind/react-complete-guide-course-resources/blob/main/code/04%20Essentials%20Deep%20Dive/11-multi-dimensional-lists/src/components/GameBoard.jsx" target="_blank">
04 Essentials Deep Dive/11-multi-dimensional-lists</a>
++++
====

=== 81. Best Practice - Updating Object State Immutably

The text describes the process of implementing state management in a React component for a game board, specifically for a Tic-Tac-Toe game. 

1. **Component Setup**: The `GameBoard` component is set up to dynamically render a grid with buttons representing game squares.

2. **State Management**: The `useState` hook is utilized to manage the game board state, which is initialized with a multidimensional array called `initialGameBoard`.

3. **Handling Button Clicks**: A function named `handleSelectSquare` is created to update the game board when a button is clicked. This function uses the `setGameBoard` to replace the corresponding square's value (from `null` to either 'X' or 'O') based on the player's turn.

4. **Immutable State Update**: It is emphasized that state updates for objects or arrays should be done immutably to avoid bugs. This involves creating a new array and copying the existing elements before making any updates.

5. **Event Handling with Parameters**: To pass the necessary row and column indices to `handleSelectSquare`, an anonymous function is created for the `onClick` event of the buttons.

6. **Final Implementation**: After implementing the above logic, clicking the buttons updates the game board correctly. However, the current implementation does not handle turn switching or win conditions.

Overall, the focus is on correctly managing and updating the game board state in a React component, while adhering to best practices for state management in JavaScript.

====
Updating Object State Immutably::
++++
<a href="https://github.com/academind/react-complete-guide-course-resources/blob/main/code/04%20Essentials%20Deep%20Dive/12-updating-state-immutably/src/components/GameBoard.jsx" target="_blank">
4 Essentials Deep Dive/12-updating-state-immutably</a>
++++
====

=== 82. Lifting State Up (Core Concept)

The text discusses the implementation of a two-player game board in React, focusing on player turn management and UI feedback. It outlines the need to switch between players, highlight the active player using CSS classes, and manage the active player state in a common ancestor component (the App component). 

Key steps include:

1. **State Management**: The active player state is lifted to the App component to allow both Player and GameBoard components to access it.
2. **Functionality**: A function (`handleSelectSquare`) is created to handle turn switching when a square is clicked, updating the active player.
3. **Props and Component Interaction**: The GameBoard component receives a prop to execute the turn-switching function, while the Player component receives an `isActive` prop to conditionally apply a CSS class for highlighting.
4. **Dynamic UI Updates**: The UI dynamically reflects the current active player and their symbols on the game board, providing visual feedback during gameplay.

The concept of "lifting state up" is emphasized as a crucial technique in React for managing shared state across components. The implementation allows for player interaction but notes that additional features like win conditions and preventing multiple clicks on the same button still need to be addressed.

====
Lifting State Up::
++++
<a href="https://github.com/academind/react-complete-guide-course-resources/blob/main/code/04%20Essentials%20Deep%20Dive/13-lifiting-state-up/src/App.jsx" target="_blank">
4 Essentials Deep Dive/13-lifiting-state-up</a>
++++
====

=== 83. Avoid Intersecting States

The focus is on improving a React application by implementing a log component that tracks the turns taken in a game. The log will display an ordered list of player turns, necessitating the management of a dynamic array of turns. To achieve this, state management needs to be lifted from the game board component to the app component, which has access to both the game board and the log. This approach will prevent redundancy in storing turn data, as the game board already reflects which buttons were clicked, albeit without the order of clicks. Instead of duplicating state, the application will manage a single array of game turns, allowing both the log and the game board to derive necessary information from it. The existing game board state that lacks ordering will be commented out, emphasizing the need for a more efficient state management strategy.

====
Avoid Intersecting States::
++++
<a href="https://github.com/academind/react-complete-guide-course-resources/blob/main/code/04%20Essentials%20Deep%20Dive/14-avoid-intersecting-state/src/App.jsx" target="_blank">
4 Essentials Deep Dive/14-avoid-intersecting-state</a>
++++
====

=== 84. Prefer Computed Values & Avoid Unnecessary State Management

The GameBoard component is being modified to remove the `activePlayerSymbol` prop and instead use the `onSelectSquare` prop for handling clicks on the squares. The game state is being lifted to the App component. The `handleSelectSquare` function will now update the turns array, ensuring that the state is updated immutably. Each turn will be represented as an object containing the player's symbol and the row and column indices of the clicked square.

The implementation ensures that the current player's symbol is determined without merging different state values, using a `currentPlayer` variable that checks the latest turn to switch between players X and O. This structure allows for a clear representation of the game's state and enables future development for displaying the game log and updating the GameBoard accordingly.

====
Prefer Computed Values::
++++
<a href="https://github.com/academind/react-complete-guide-course-resources/blob/main/code/04%20Essentials%20Deep%20Dive/15-prefer-computed-values/src/components/GameBoard.jsx" target="_blank">
4 Essentials Deep Dive/15-prefer-computed-values</a>
++++
====

=== 85. Deriving State From Props

The passage outlines the implementation details of a game board component in a React application. The goal is to derive the game board's state from an array of game turns. Key steps include:

1. **Passing Props**: A new `turns` prop is passed to the `Gameboard` component, which contains the array of turns.
   
2. **State Derivation**: The game board is initialized with its default structure. A loop iterates through the `turns` array to extract relevant information (square and player) from each turn's object. This information is used to update the corresponding cell in the game board.

3. **Object Destructuring**: The code employs object destructuring to efficiently extract properties from the turn objects and their nested square objects.

4. **Error Handling**: An error occurs due to missing row and column indices in the `handleSelectSquare` function's implementation, which is tied to the button's `onClick` event. 

5. **Fixing the Error**: The solution involves using an anonymous function in the `onClick` event to pass the row and column indices, ensuring the correct data is provided to `handleSelectSquare`.

6. **Outcome**: After implementing these changes, the game board updates correctly upon button clicks and can reflect the current game state derived from the `turns` array. Additionally, there's a plan to log the game turns for better debugging and oversight in future lectures.

