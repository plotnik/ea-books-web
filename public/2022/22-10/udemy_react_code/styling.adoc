= 6. Styling React Components
:icons: font
:toc: left

link:udemy_react.html[<Contents>]


=== 105. Module Introduction & Starting Project

The section focuses on styling React components and applications, emphasizing that it is not a CSS course but an introduction to applying CSS within React. It outlines various options for styling, starting with Vanilla CSS, and then progressing to more advanced techniques. Key topics include:

- **CSS Modules** for scoping styles to specific components.
- **Styled Components**, a CSS-in-JS library, exploring its benefits and drawbacks.
- **Tailwind CSS**, a popular utility-first CSS framework for styling React apps.

The course will cover both static styles and dynamic, conditional styles. A starting project is provided for hands-on practice, which includes basic styling with Vanilla CSS. Participants will learn how to set up the project and see some initial styles applied, although some interactive elements like account creation and sign-in will not function yet. The next lecture will begin with applying styles using Vanilla CSS.

=== 106. Splitting CSS Code Across Multiple Files

The text discusses styling options for React applications, particularly focusing on the use of CSS files. It explains that you can create a CSS file, such as an `index.css`, to define your styles using various selectors (element, ID, class), and then import this CSS file into your JavaScript files. Using a build tool like Vite, the CSS is dynamically injected into the webpage, which can be confirmed through the developer tools.

Additionally, it emphasizes that you are not limited to a single CSS file; you can create multiple CSS files for better organization. For instance, you can separate styles related to specific components, like a `header.css` for header-specific rules, and import this file in the corresponding component file (e.g., `header.jsx`). After making these changes, the page will maintain the same appearance as the styles are still injected correctly by Vite, resulting in multiple style tags in the head section of the webpage.

====
Splitting CSS Code::
++++
<a href="https://github.com/academind/react-complete-guide-course-resources/blob/main/code/07%20Styling/01-starting-project/src/main.jsx" target="_blank">
07 Styling/01-starting-project</a>
++++
====

=== 107. Styling React Apps with Vanilla CSS - Pros & Cons

The lecture discusses the use of Vanilla CSS for styling React applications. Key advantages include the ease of importing CSS files into JSX, allowing collaboration between developers and designers without interference, and the ability to write standard CSS without special conventions. This separation of concerns enables different team members to work on components and styles independently. However, there are disadvantages, such as the necessity of knowing CSS to write it effectively and the potential for styling clashes due to the lack of component scoping in Vanilla CSS. The lecturer mentions that the latter issue will be explored in more detail in the next session.

=== 108. Vanilla CSS Styles Are NOT Scoped To Components!

The lecture discusses a key disadvantage of using Vanilla CSS: the lack of component-specific scoping for CSS rules. An example is provided with a `Header.css` file, where styles intended for a header affect paragraphs across different components, such as `AuthInputs.jsx`. When a paragraph is added in `AuthInputs`, it inherits styles from `Header.css`, demonstrating that CSS rules are applied globally rather than being restricted to the component they are imported into. This highlights the importance of understanding that CSS in Vanilla CSS is not scoped and is injected into the head of the document, affecting all applicable elements on the page. The speaker emphasizes reverting changes made during the demonstration to maintain intended styles.

=== 109. Styling React Apps with Inline Styles

The text discusses the limitations of using vanilla CSS in web development, specifically its lack of component scoping, and suggests inline styles as a solution. Inline styles, applied via the `style` prop in JSX for React applications, allow styles to be directly associated with specific elements. This approach offers the advantage of styles affecting only the targeted element, providing easy and precise styling. However, it also has drawbacks, such as the need to manually style each element individually and the lack of separation between CSS and JSX code, which can complicate collaboration between developers and designers. Additionally, inline styles facilitate dynamic and conditional styling, an aspect that will be explored further in subsequent discussions.

=== 110. Dynamic & Conditional Inline Styles

The content discusses a method of applying conditional inline styles to input fields, particularly focusing on styling invalid inputs. Initially, the author considers inline styling for inputs in a project, but decides to conditionally style inputs based on their validity using a ternary expression. This involves setting a background color based on whether an input is valid or not, using a constant to determine the condition. The approach is demonstrated with an example where an invalid email input is highlighted in red. However, the author acknowledges the downsides of inline styling, such as code duplication and cluttering JSX with CSS, and suggests exploring conditional styling using class names with vanilla CSS as a more efficient alternative.

====
Dynamic & Conditional Inline Styles::
++++
<a href="https://github.com/academind/react-complete-guide-course-resources/blob/main/code/07%20Styling/02-dynamic-conditional-inline-styles/src/components/AuthInputs.jsx" target="_blank">
07-Styling/02-dynamic-conditional-inline-styles/src/components/AuthInputs.jsx</a>
++++
====

=== 111. Dynamic & Conditional Styling with CSS Files & CSS Classes

This text discusses how to dynamically style elements in React applications using CSS class names instead of inline styles. It emphasizes the use of conditional class names, explaining that ternary expressions should be used instead of the `&&` shortcut to avoid adding boolean values as class names and causing console warnings. The text also explains how to combine a class that is always applied with a conditional class, using template literals with backticks and `${}` syntax to dynamically construct the class name string. An example is provided using a label element with a permanent "label" class and a conditional "invalid" class based on whether an input field is valid. The explanation concludes with demonstrating how the same approach can be applied to multiple elements.

=== 112. Scoping CSS Rules with CSS Modules

This section discusses the limitations of using plain CSS in React applications, specifically the lack of scoping, which can lead to unintended style conflicts between components. The example given is a paragraph style in the header affecting labels in other components. The solution is to use CSS Modules, which automatically scopes styles to the component where they are imported. This is done by renaming the CSS file with the `.module.css` extension and importing it as a JavaScript object containing transformed class names. The build process generates unique class names for each component, ensuring that styles do not interfere with other components. This approach allows for CSS code to be decoupled from JSX, written as Vanilla CSS and allows for conditional application of styles. However, it may result in many small CSS files.

=== 113. Introducing Styled Components (Third-party Package)

This section introduces the styled-components package as an alternative to traditional CSS styling in React. Instead of separate CSS files or inline styles, styled-components allows you to define styles directly within your React components using special "styled" components.

Here's a breakdown of the key points:

*   **Installation:** The package is installed using `npm install styled-components` or by adding it as a dependency in CodeSandbox.
*   **Import `styled`:** You import `styled` from the `styled-components` package.
*   **Creating Styled Components:** You use `styled.element` (e.g., `styled.div`, `styled.h1`, `styled.p`) followed by backticks (``) to create a styled component.
*   **Tagged Templates:** The backticks create a tagged template, which is a JavaScript feature that allows you to embed styles directly into the component definition.
*   **CSS Inside:** Inside the backticks, you write standard CSS code, including multi-line styles.
*   **Component Creation:** This process creates a new React component that renders the specified HTML element with the provided CSS styles.
*   **Usage:** You then use this newly created component in your React application.
*   **Internal Mechanism:** Under the hood, styled-components generates unique CSS class names and injects the corresponding styles into the `<head>` of the document.
*   **Dynamic Elements:** You can change the HTML element rendered by changing the property called on the `styled` object, such as `styled.div` to `styled.p`.

In essence, styled-components provides a way to encapsulate both the structure and style of a component within a single, reusable entity, making it easier to manage styles and create more maintainable React applications. The example given then shows how to replace a div in a component with a styled div using the `styled-components` package.

=== 114. Creating Flexible Components with Styled Components

The content discusses the process of integrating styled components into a React application to manage styling. It explains how styled components can be used alongside other styling methods like CSS modules, though typically one would choose a single approach for the entire app. The process involves creating styled components for elements like labels and inputs by defining constants with `styled.label` or `styled.input` and applying styles using backticks. These styled components forward all props to the underlying JSX elements, making it convenient to add features like class names or event listeners. The explanation emphasizes that styled components do not alter the functionality of props, ensuring existing functionalities like validation and event handling continue to work seamlessly.

====
Creating Flexible Components with Styled Components::
++++
<a href="https://github.com/academind/react-complete-guide-course-resources/blob/main/code/07%20Styling/05-styled-cmp-creating-reusable-cmp/src/components/AuthInputs.jsx" target="_blank">
07 Styling/05-styled-cmp-creating-reusable-cmp/src/components/AuthInputs.jsx</a>
++++
====

=== 115. Dynamic & Conditional Styling with Styled Components

The passage explains how to use styled components in React to encapsulate and reuse styling without resorting to inline styles or duplicated CSS classes. It shows that by creating small wrapper components with styled components, styles can be kept close to the JSX code while remaining separate. The discussion then focuses on dynamically styling elements based on props—such as an `invalid` or `$invalid` prop—to conditionally change properties like text color, background color, and border color. This dynamic styling is achieved through a special injection syntax in template literals that executes a function receiving the component’s props, allowing the style to change depending on whether a condition (like form validation) is met. A noteworthy point is the importance of avoiding name clashes with built-in props by prefixing custom props with a dollar sign (e.g., `$invalid`), which prevents warnings and ensures the styled component behaves as intended.


=== 116. Styled Components - Pseudo Selectors, Nested Rules & Media Queries

The content describes how to utilize styled components for creating and styling React components, focusing on media queries, pseudo-selectors, and nesting rules.

1. **Media Queries and Nested Selectors**: The author explains how to replace a standard header with a styled header in a React component. By importing styled from 'styled-components', they create a `StyledHeader` component and apply styles using template literals. They discuss how to ensure that images and other elements within the header are styled by using the ampersand symbol (`&`) to target nested elements.

2. **CSS Cleanup**: The risk of breaking styles when removing CSS imports is noted, and the author suggests copying existing CSS rules, including media queries, into styled components. This allows for a smooth transition while maintaining styles for different screen sizes.

3. **Pseudo-selectors**: The author demonstrates creating a styled button component and applying hover effects using the `&:hover` syntax. This directs the hover styles to the button itself rather than child elements.

The overall message is that by converting to styled components, developers can effectively manage component styles and utilize CSS features like media queries and hover effects without complex changes. The author emphasizes the ease of styling parents that can influence child elements and encourages practicing the migration of components into styled components.

=== 117. Creating Reusable Components & Component Combinations

The content discusses the use of styled components in React applications, highlighting the process of organizing and structuring these components effectively. It begins by examining the `AuthInputs.jsx` file, where several styled components (div, label, input, button) are created. The author suggests that some components, like the `ControlContainer`, are specific to `AuthInputs.jsx`, while others, such as the label, input, and button, could be reused across the application.

To enhance reusability, it is recommended to create separate files for commonly used components, such as `Button.jsx`, `Input.jsx`, and `Label.jsx`. The author demonstrates how to move the button component into `Button.jsx`, ensuring it can be imported back into `AuthInputs.jsx`, maintaining its functionality while allowing reuse in other components.

For the label and input components, the suggestion is given to combine them into a single component called `CustomInput`. This new component accepts a `label` prop and other passed props, ensuring a clean and reusable design. After creating `CustomInput`, it is imported and used in `AuthInputs.jsx`, simplifying the structure.

The discussion concludes with advantages of styled components, including ease of setup, automatic scoping of styles, and the ability to stay within the React paradigm. However, it also notes the need for CSS knowledge, the blending of React and CSS code, and the potential creation of numerous small components, which can be cumbersome despite being a core aspect of React development.

=== 118. Introducing Tailwind CSS For React App Styling

This section introduces Tailwind CSS, a popular utility-first CSS framework that works well with React and any other web projects. The instructor explains that Tailwind uses many small utility classes added directly to HTML elements to style components, which can seem overwhelming at first but becomes manageable with practice and the help of tools like the Tailwind IntelliSense extension in Visual Studio Code.

The tutorial walks through basic setup steps for integrating Tailwind into a project. This includes installing the necessary packages, initializing Tailwind, and modifying configuration files to specify content sources. It also involves replacing the existing CSS by adding required Tailwind directives to the main CSS file.

Once Tailwind is set up, the demo shows how to gradually convert component styling from previous methods to Tailwind. For example, the header is restyled using Flexbox utility classes along with margin, width, and text-related classes to achieve a centered layout with appropriate spacing, sizing, and color styling. The instructor highlights that while the class names may look cryptic initially, frequent use and referencing the documentation will help in learning them over time.

In summary, the content provides an introductory guide to using Tailwind CSS for styling by:

• Setting up Tailwind via installation commands and configuration changes.
• Replacing existing CSS with Tailwind’s utility classes.
• Demonstrating practical examples of re-styling components with utility classes.
• Recommending the official documentation and dedicated courses for deeper dives into Tailwind’s customization options.
