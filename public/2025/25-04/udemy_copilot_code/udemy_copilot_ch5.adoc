= AI For Developers With GitHub Copilot, Cursor AI & ChatGPT - *Chapter 5. Practice Project: Creating a REST API with AI*
:source-highlighter: coderay
:icons: font
:toc: left
:toclevels: 4
Maximilian Schwarzmüller

https://www.udemy.com/course/ai-for-developers-with-github-copilot-cursor-ai-chatgpt/

== Planning the Application Structure with ChatGPT

Here’s a concise, reorganized version of your narrative—suitable for a
README, slide deck, or blog post—highlighting objectives, AI‐driven
planning, and next steps.

[arabic]
. Project Overview +
• Build a REST API with Node.js & Express +
• Core features: +
– User authentication (register, login) +
– CRUD for events (title, description, date, location, image) +
– Event registration/unregistration +
– Image uploads
. Why Use ChatGPT for Planning? +
• Capture missing requirements early +
• Get concrete suggestions for architecture, models, and routes +
• Validate best practices (e.g. password hashing, token‐based auth) +
• Stay in control—accept, tweak, or ignore any suggestion
. Prompt Structure +
Role assigned: “You’re my technical architect.” +
Requirements summary: +
– REST API in Node.js/Express +
– JWT authentication + bcrypt for passwords +
– Event model fields + image upload +
– Registration endpoints +
Instruction: “Don’t generate code now—just outline building blocks &
project structure.”
. Key AI-Generated Suggestions +
A. Project Structure +
• src/ +
– controllers/ +
– models/ +
– routes/ +
– middleware/ +
– config/ +
• public/uploads/ (for images) +
• server.js, .env, package.json +
B. Authentication +
• JSON Web Tokens (JWT) for stateless sessions +
• bcrypt to hash passwords +
C. Data Models
[arabic]
.. User \{ username, email, passwordHash }
.. Event \{ title, description, date, location, imagePath, creatorId }
.. Registration \{ userId, eventId, registeredAt } +
D. Endpoints +
• POST /auth/register, /auth/login +
• GET /users/me +
• GET/POST/PUT/DELETE /events +
• POST /events/:id/register, DELETE /events/:id/unregister +
• GET /events/:id/registrations +
E. Middleware & Utilities +
• authMiddleware (verify JWT) +
• errorHandler +
• uploadMiddleware (e.g. multer)
. Customizations & Decisions +
• Move uploads folder to public directory (not under src/) +
• Skip Mongoose/SQLite—choose preferred ORM or database +
• Adapt folder names and granularities to team conventions
. Next Steps
[arabic]
.. Switch to Cursor (or your IDE)
.. Scaffold files and folders per agreed structure
.. Use GitHub Copilot or AI tools to generate and refine code
.. Iteratively test auth flows, CRUD operations, and file uploads

With this plan in hand, you’ll hit the ground running—no surprises, no
forgotten endpoints, and a clear roadmap for implementation.

== Setting Up the Project in Cursor AI
Here’s a cleaner, more focused step-by-step setup for your
Node.js/Express REST API project:

[arabic]
. Create a new project folder +
mkdir my-rest-api +
cd my-rest-api
. Initialize npm
+
[source,bash]
----
npm init -y
----
+
This generates a basic package.json.
. Edit package.json +
• Set “name”, “author” (your name/company) +
• Change `+"main"+` to `+"app.js"+` +
• Add `+"type": "module"+` to enable ES module syntax +
• Under `+"scripts"+`, replace `+"test"+` with:
+
[source,json]
----
"dev": "node --watch app.js"
----
+
This uses Node’s built-in watch mode so your server restarts on file
changes.
. Create a .env file +
Store secrets or configuration there, e.g.:
+
[source,dotenv]
----
JWT_SECRET=your_super_secret_key
PORT=3000
----
. Create a .gitignore
+
[source,gitignore]
----
node_modules/
.env
.DS_Store
----
. Install Express
+
[source,bash]
----
npm install express
----
. Create your entry point: app.js +
In app.js, start with a minimal Express server:
+
[source,js]
----
import express from 'express';
import dotenv from 'dotenv';

dotenv.config();

const app = express();
const port = process.env.PORT || 3000;

app.use(express.json());

app.get('/', (req, res) => {
  res.send('Hello, world!');
});

app.listen(port, () => {
  console.log(`Server listening on http://localhost:${port}`);
});
----
. Scaffold your folder structure +
At the project root, create these directories: • controllers/ +
• models/ +
• routes/ +
• public/images/
+
You’ll place route definitions in routes/, business logic in
controllers/, data schemas or ORM models in models/, and any static
assets (like uploaded images) in public/.
. Next steps with AI tooling (optional) +
Now that the foundation is laid, you can leverage tools like Cursor or
ChatGPT to generate boilerplate code inside your
controllers/models/routes folders—saving you from writing every endpoint
by hand.
. Run your server
+
[source,bash]
----
npm run dev
----
+
Visit http://localhost:3000 to verify it’s up and running.

From here, gradually add your resource routes (e.g. users, products),
connect to a database, and flesh out controllers and models. This
structure keeps your code organized and makes collaboration much
smoother.

== Writing User Registration & Login Code with Cursor Composer

=== 1. Context & Strategy

I’m building a REST API and want to tackle it in small, manageable
chunks. +
My first slice is *user registration & login*. Rather than dumping the
entire app spec into one prompt, I’ll:

[arabic]
. Define exactly what I need for authentication (no JWT/database yet).
. Split that into a clear, targeted prompt for CursorComposer.
. Review the generated files and refine as needed.

'''''

=== 2. First Prompt to CursorComposer

[source,text]
----
This REST API needs user authentication.  
Users must be able to register (sign up) and log in.  

Requirements:
- No JWT or database code yet—just the model, routes, and controller stubs.  
- Use plain functions (not classes).  
- Place files under:  
  • models/user.js  
  • controllers/userController.js  
  • routes/users.js  

- In models/user.js, export two separate functions: createUser(data) and authenticateUser(data).  
- In routes/users.js, set up:  
  • POST /users/signup → calls createUser  
  • POST /users/login  → calls authenticateUser  

- In controllers/userController.js, export matching functions.  
- Wire up the routes in app.js under the “/users” prefix.  
- Include Express’s JSON body-parser middleware.

Don’t add database persistence code yet; we’ll handle that in a later step.
----

'''''

=== 3. Generated Output (Summary)

CursorComposer gave me:

• `models/user.js` +
   Exports a single object with two methods (I wanted two functions instead). 
• `routes/users.js` +
   Defines `+/signup+` and `+/login+` routes correctly. 
• `controllers/userController.js` +
  Exports an object mirroring `models/user`. +
• `app.js` +
  Imports `+express.json()+` +
  Mounts `+routes/users.js+` at `+/users+`

Overall—good structure and folder layout, plus body-parser middleware.

'''''

=== 4. What I’d Tweak Next

[arabic]
. *Separate Functions* +
`models/user.js` → export `+createUser()+` and `+authenticateUser()+`
instead of one object.
. *Consistent Naming* +
Align function names between models, controllers, and routes.
. *Folder Paths* +
Confirm controllers go into `+/controllers+` (not “controller’s” or
“controllers folder”).
. *Error Handling Stub* +
Add basic `+try/catch+` blocks and `+res.status()+` calls in
controllers.

'''''

=== 5. Next Prompt Refinement

[source,text]
----
Please update the files you generated to:

1. In `models/user.js`:
   • Export two named functions:  
     - async function createUser({ email, password })  
     - async function authenticateUser({ email, password })
   • Do not wrap them in an object—use separate exports.

2. In `controllers/userController.js`:
   • Import the two functions by name.
   • Add try/catch around each call, sending 200 or 400 with JSON messages.

3. Ensure routes/users.js uses:
   • `const { createUser, authenticateUser } = require('../models/user');`
   • `const { signup, login } = require('../controllers/userController');`
   • `router.post('/signup', signup);`
   • `router.post('/login', login);`

4. No database code yet—just stub responses.
----

That gives CursorComposer a precise second pass to align everything
exactly how I need it.

== Providing Follow-Up Feedback To Cursor Composer

[arabic]
. Goals
* Keep everything as standalone functions rather than methods on
objects.
* Switch from CommonJS (`+require+`/`+module.exports+`) to modern ESM
(`+import+`/`+export+`).
. Iteration with the AI assistant (Cursor) +
• First feedback: _“Don’t wrap methods in objects—export independent functions in every file.”_ +
• Result:
* `+createUser(data)+` and `+findUserByEmail(email)+` appeared as
top-level functions.
* No database logic was added yet, per earlier instructions. +
• Second feedback: _“Convert all import/export statements to ESM syntax.”_ +
• Result:
* `+export function …+` and `+import { … } from '…'+` replaced CommonJS.
* Cursor added `+type: "module"+` in `+package.json+` (which I’d already
set), and tweaked `+.gitignore+`.
. Accepting/rejecting changes
* Accepted updates to `+user.js+`, `+users.js+`, and
`+users.controller.js+`.
* Rejected the redundant `+package.json+` change.
* Accepted the minor `+.gitignore+` tweak.
. Manual refinements
* Renamed files to match my preferred naming convention.
* Converted arrow functions to named function declarations for clarity:
+
[source,js]
----
// Before
export const createUser = (data) => { … }
// After
export function createUser(data) { … }
----
* Cursor’s autocompletion spotted the pattern and quickly applied the
same transform to `+findUserByEmail()+` and the controller functions.

Outcome: a clean, ESM-based codebase composed of plain, exported
functions—ready for the next development steps.

== Connecting to A SQLite Database with Cursor's Sidebar Chat

> i want to store data in sqlite database. how would i add one to the application?

> i want to use better-sqlite3 package. update you response accordingly

Here’s a much tighter, step-by-step guide for swapping your in-memory
user store out for a SQLite database using the better-sqlite3 package in
a Node/Express REST API.

Prerequisites +
• You already have an Express app (app.js) and a basic
`+models/user.js+`. +
• Routes exist to “create user” and “find user by email.”

Goal +
Persist user data in SQLite instead of keeping it in memory.

'''''

[arabic]
. Install better-sqlite3
+
[source,bash]
----
npm install better-sqlite3
----
. Create a database module +
Next to `+app.js+`, add `+database.js+`:
+
[source,js]
----
// database.js
const Database = require('better-sqlite3');
let db;

function initializeDatabase(filePath = './data.db') {
  db = new Database(filePath);
  db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id       INTEGER PRIMARY KEY,
      email    TEXT UNIQUE    NOT NULL,
      password TEXT           NOT NULL
    );
  `);
  return db;
}

function getDatabase() {
  if (!db) throw new Error('Database not initialized');
  return db;
}

module.exports = { initializeDatabase, getDatabase };
----
. Update your user model +
In `+models/user.js+`, replace whatever you had with:
+
[source,js]
----
// models/user.js
const { getDatabase } = require('../database');

function createUser({ email, password }) {
  const db   = getDatabase();
  const stmt = db.prepare('INSERT INTO users (email, password) VALUES (?, ?)');
  const info = stmt.run(email, password);
  return { id: info.lastInsertRowid, email, password };
}

function findUserByEmail(email) {
  const db   = getDatabase();
  const stmt = db.prepare('SELECT id, email, password FROM users WHERE email = ?');
  return stmt.get(email);
}

module.exports = { createUser, findUserByEmail };
----
. Wire up the database in your app entrypoint +
In `+app.js+`, import and initialize before registering routes:
+
[source,js]
----
// app.js
const express = require('express');
const { initializeDatabase } = require('./database');

const app = express();

try {
  initializeDatabase('./data.db');
  console.log('✅ SQLite database initialized');
} catch (err) {
  console.error('❌ Failed to initialize database:', err);
  process.exit(1);
}

app.use(express.json());
// require('./routes/users')(app)  – your user routes here

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server listening on port ${PORT}`);
});
----
. Test it +
• Start your server. +
• POST to `+/users+` with `+{ "email": "...", "password": "..." }+`. +
• Verify `+data.db+` contains your new user (e.g. via
`+sqlite3 data.db "SELECT * FROM users;"+`).

That’s it! You now have a persistent SQLite store backing your
user-creation endpoints, all via better-sqlite3.

====
Sign up a new user:
```
curl -X POST http://localhost:3000/users/signup \
  -H "Content-Type: application/json" \
  -d '{"email": "user@example.com", "password": "password123"}'
```

---
Login with the created user:
```
curl -X POST http://localhost:3000/users/login \
  -H "Content-Type: application/json" \
  -d '{"email": "user@example.com", "password": "password123"}'
```

====