= AI For Developers With GitHub Copilot, Cursor AI & ChatGPT - *Chapter 5. Practice Project: Creating a REST API with AI*
:source-highlighter: coderay
:icons: font
:toc: left
:toclevels: 4
Maximilian Schwarzmüller

https://www.udemy.com/course/ai-for-developers-with-github-copilot-cursor-ai-chatgpt/

== Planning the Application Structure with ChatGPT

Here’s a concise, reorganized version of your narrative—suitable for a
README, slide deck, or blog post—highlighting objectives, AI‐driven
planning, and next steps.

[arabic]
. Project Overview +
• Build a REST API with Node.js & Express +
• Core features: +
– User authentication (register, login) +
– CRUD for events (title, description, date, location, image) +
– Event registration/unregistration +
– Image uploads
. Why Use ChatGPT for Planning? +
• Capture missing requirements early +
• Get concrete suggestions for architecture, models, and routes +
• Validate best practices (e.g. password hashing, token‐based auth) +
• Stay in control—accept, tweak, or ignore any suggestion
. Prompt Structure +
Role assigned: “You’re my technical architect.” +
Requirements summary: +
– REST API in Node.js/Express +
– JWT authentication + bcrypt for passwords +
– Event model fields + image upload +
– Registration endpoints +
Instruction: “Don’t generate code now—just outline building blocks &
project structure.”
. Key AI-Generated Suggestions +
A. Project Structure +
• src/ +
– controllers/ +
– models/ +
– routes/ +
– middleware/ +
– config/ +
• public/uploads/ (for images) +
• server.js, .env, package.json +
B. Authentication +
• JSON Web Tokens (JWT) for stateless sessions +
• bcrypt to hash passwords +
C. Data Models
[arabic]
.. User \{ username, email, passwordHash }
.. Event \{ title, description, date, location, imagePath, creatorId }
.. Registration \{ userId, eventId, registeredAt } +
D. Endpoints +
• POST /auth/register, /auth/login +
• GET /users/me +
• GET/POST/PUT/DELETE /events +
• POST /events/:id/register, DELETE /events/:id/unregister +
• GET /events/:id/registrations +
E. Middleware & Utilities +
• authMiddleware (verify JWT) +
• errorHandler +
• uploadMiddleware (e.g. multer)
. Customizations & Decisions +
• Move uploads folder to public directory (not under src/) +
• Skip Mongoose/SQLite—choose preferred ORM or database +
• Adapt folder names and granularities to team conventions
. Next Steps
[arabic]
.. Switch to Cursor (or your IDE)
.. Scaffold files and folders per agreed structure
.. Use GitHub Copilot or AI tools to generate and refine code
.. Iteratively test auth flows, CRUD operations, and file uploads

With this plan in hand, you’ll hit the ground running—no surprises, no
forgotten endpoints, and a clear roadmap for implementation.

== Setting Up the Project in Cursor AI
Here’s a cleaner, more focused step-by-step setup for your
Node.js/Express REST API project:

[arabic]
. Create a new project folder +
mkdir my-rest-api +
cd my-rest-api
. Initialize npm
+
[source,bash]
----
npm init -y
----
+
This generates a basic package.json.
. Edit package.json +
• Set “name”, “author” (your name/company) +
• Change `+"main"+` to `+"app.js"+` +
• Add `+"type": "module"+` to enable ES module syntax +
• Under `+"scripts"+`, replace `+"test"+` with:
+
[source,json]
----
"dev": "node --watch app.js"
----
+
This uses Node’s built-in watch mode so your server restarts on file
changes.
. Create a .env file +
Store secrets or configuration there, e.g.:
+
[source,dotenv]
----
JWT_SECRET=your_super_secret_key
PORT=3000
----
. Create a .gitignore
+
[source,gitignore]
----
node_modules/
.env
.DS_Store
----
. Install Express
+
[source,bash]
----
npm install express
----
. Create your entry point: app.js +
In app.js, start with a minimal Express server:
+
[source,js]
----
import express from 'express';
import dotenv from 'dotenv';

dotenv.config();

const app = express();
const port = process.env.PORT || 3000;

app.use(express.json());

app.get('/', (req, res) => {
  res.send('Hello, world!');
});

app.listen(port, () => {
  console.log(`Server listening on http://localhost:${port}`);
});
----
. Scaffold your folder structure +
At the project root, create these directories: • controllers/ +
• models/ +
• routes/ +
• public/images/
+
You’ll place route definitions in routes/, business logic in
controllers/, data schemas or ORM models in models/, and any static
assets (like uploaded images) in public/.
. Next steps with AI tooling (optional) +
Now that the foundation is laid, you can leverage tools like Cursor or
ChatGPT to generate boilerplate code inside your
controllers/models/routes folders—saving you from writing every endpoint
by hand.
. Run your server
+
[source,bash]
----
npm run dev
----
+
Visit http://localhost:3000 to verify it’s up and running.

From here, gradually add your resource routes (e.g. users, products),
connect to a database, and flesh out controllers and models. This
structure keeps your code organized and makes collaboration much
smoother.

== Writing User Registration & Login Code with Cursor Composer

=== 1. Context & Strategy

I’m building a REST API and want to tackle it in small, manageable
chunks. +
My first slice is *user registration & login*. Rather than dumping the
entire app spec into one prompt, I’ll:

[arabic]
. Define exactly what I need for authentication (no JWT/database yet).
. Split that into a clear, targeted prompt for CursorComposer.
. Review the generated files and refine as needed.

'''''

=== 2. First Prompt to CursorComposer

[source,text]
----
This REST API needs user authentication.  
Users must be able to register (sign up) and log in.  

Requirements:
- No JWT or database code yet—just the model, routes, and controller stubs.  
- Use plain functions (not classes).  
- Place files under:  
  • models/user.js  
  • controllers/userController.js  
  • routes/users.js  

- In models/user.js, export two separate functions: createUser(data) and authenticateUser(data).  
- In routes/users.js, set up:  
  • POST /users/signup → calls createUser  
  • POST /users/login  → calls authenticateUser  

- In controllers/userController.js, export matching functions.  
- Wire up the routes in app.js under the “/users” prefix.  
- Include Express’s JSON body-parser middleware.

Don’t add database persistence code yet; we’ll handle that in a later step.
----

'''''

=== 3. Generated Output (Summary)

CursorComposer gave me:

• `models/user.js` +
   Exports a single object with two methods (I wanted two functions instead). 
• `routes/users.js` +
   Defines `+/signup+` and `+/login+` routes correctly. 
• `controllers/userController.js` +
  Exports an object mirroring `models/user`. +
• `app.js` +
  Imports `+express.json()+` +
  Mounts `+routes/users.js+` at `+/users+`

Overall—good structure and folder layout, plus body-parser middleware.

'''''

=== 4. What I’d Tweak Next

[arabic]
. *Separate Functions* +
`models/user.js` → export `+createUser()+` and `+authenticateUser()+`
instead of one object.
. *Consistent Naming* +
Align function names between models, controllers, and routes.
. *Folder Paths* +
Confirm controllers go into `+/controllers+` (not “controller’s” or
“controllers folder”).
. *Error Handling Stub* +
Add basic `+try/catch+` blocks and `+res.status()+` calls in
controllers.

'''''

=== 5. Next Prompt Refinement

[source,text]
----
Please update the files you generated to:

1. In `models/user.js`:
   • Export two named functions:  
     - async function createUser({ email, password })  
     - async function authenticateUser({ email, password })
   • Do not wrap them in an object—use separate exports.

2. In `controllers/userController.js`:
   • Import the two functions by name.
   • Add try/catch around each call, sending 200 or 400 with JSON messages.

3. Ensure routes/users.js uses:
   • `const { createUser, authenticateUser } = require('../models/user');`
   • `const { signup, login } = require('../controllers/userController');`
   • `router.post('/signup', signup);`
   • `router.post('/login', login);`

4. No database code yet—just stub responses.
----

That gives CursorComposer a precise second pass to align everything
exactly how I need it.

== Providing Follow-Up Feedback To Cursor Composer

[arabic]
. Goals
* Keep everything as standalone functions rather than methods on
objects.
* Switch from CommonJS (`+require+`/`+module.exports+`) to modern ESM
(`+import+`/`+export+`).
. Iteration with the AI assistant (Cursor) +
• First feedback: _“Don’t wrap methods in objects—export independent functions in every file.”_ +
• Result:
* `+createUser(data)+` and `+findUserByEmail(email)+` appeared as
top-level functions.
* No database logic was added yet, per earlier instructions. +
• Second feedback: _“Convert all import/export statements to ESM syntax.”_ +
• Result:
* `+export function …+` and `+import { … } from '…'+` replaced CommonJS.
* Cursor added `+type: "module"+` in `+package.json+` (which I’d already
set), and tweaked `+.gitignore+`.
. Accepting/rejecting changes
* Accepted updates to `+user.js+`, `+users.js+`, and
`+users.controller.js+`.
* Rejected the redundant `+package.json+` change.
* Accepted the minor `+.gitignore+` tweak.
. Manual refinements
* Renamed files to match my preferred naming convention.
* Converted arrow functions to named function declarations for clarity:
+
[source,js]
----
// Before
export const createUser = (data) => { … }
// After
export function createUser(data) { … }
----
* Cursor’s autocompletion spotted the pattern and quickly applied the
same transform to `+findUserByEmail()+` and the controller functions.

Outcome: a clean, ESM-based codebase composed of plain, exported
functions—ready for the next development steps.

== Connecting to A SQLite Database with Cursor's Sidebar Chat

> i want to store data in sqlite database. how would i add one to the application?

> i want to use better-sqlite3 package. update you response accordingly

Here’s a much tighter, step-by-step guide for swapping your in-memory
user store out for a SQLite database using the better-sqlite3 package in
a Node/Express REST API.

Prerequisites +
• You already have an Express app (app.js) and a basic
`+models/user.js+`. +
• Routes exist to “create user” and “find user by email.”

Goal +
Persist user data in SQLite instead of keeping it in memory.

'''''

[arabic]
. Install better-sqlite3
+
[source,bash]
----
npm install better-sqlite3
----
. Create a database module +
Next to `+app.js+`, add `+database.js+`:
+
[source,js]
----
// database.js
const Database = require('better-sqlite3');
let db;

function initializeDatabase(filePath = './data.db') {
  db = new Database(filePath);
  db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id       INTEGER PRIMARY KEY,
      email    TEXT UNIQUE    NOT NULL,
      password TEXT           NOT NULL
    );
  `);
  return db;
}

function getDatabase() {
  if (!db) throw new Error('Database not initialized');
  return db;
}

module.exports = { initializeDatabase, getDatabase };
----
. Update your user model +
In `+models/user.js+`, replace whatever you had with:
+
[source,js]
----
// models/user.js
const { getDatabase } = require('../database');

function createUser({ email, password }) {
  const db   = getDatabase();
  const stmt = db.prepare('INSERT INTO users (email, password) VALUES (?, ?)');
  const info = stmt.run(email, password);
  return { id: info.lastInsertRowid, email, password };
}

function findUserByEmail(email) {
  const db   = getDatabase();
  const stmt = db.prepare('SELECT id, email, password FROM users WHERE email = ?');
  return stmt.get(email);
}

module.exports = { createUser, findUserByEmail };
----
. Wire up the database in your app entrypoint +
In `+app.js+`, import and initialize before registering routes:
+
[source,js]
----
// app.js
const express = require('express');
const { initializeDatabase } = require('./database');

const app = express();

try {
  initializeDatabase('./data.db');
  console.log('✅ SQLite database initialized');
} catch (err) {
  console.error('❌ Failed to initialize database:', err);
  process.exit(1);
}

app.use(express.json());
// require('./routes/users')(app)  – your user routes here

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server listening on port ${PORT}`);
});
----
. Test it +
• Start your server. +
• POST to `+/users+` with `+{ "email": "...", "password": "..." }+`. +
• Verify `+data.db+` contains your new user (e.g. via
`+sqlite3 data.db "SELECT * FROM users;"+`).

That’s it! You now have a persistent SQLite store backing your
user-creation endpoints, all via better-sqlite3.

====
Sign up a new user:
```
curl -X POST http://localhost:3000/users/signup \
  -H "Content-Type: application/json" \
  -d '{"email": "user@example.com", "password": "password123"}'
```

---
Login with the created user:
```
curl -X POST http://localhost:3000/users/login \
  -H "Content-Type: application/json" \
  -d '{"email": "user@example.com", "password": "password123"}'
```

==== 

== Tweaking AI-Generated Code

Here’s a more concise, structured explanation of what we’re doing in
*app.js*:

[arabic]
. Start the server before initializing the database +
• Instead of exporting the Express app and initializing the DB
immediately, call `+app.listen(...)+` right away. +
• In the listen callback (i.e. once the server has successfully
started), run your database‐initialization logic. +
• If the server fails to start, the callback never fires, so you never
attempt to initialize the database.
. Use a configurable port +
• Read the port from `+process.env.PORT+` when available, otherwise fall
back to `+3000+`. +
• This lets you adapt to hosting environments that assign dynamic ports.
+
[source,js]
----
const port = process.env.PORT || 3000;
----
. Full flow in *app.js* +
• Configure middleware and routes first (e.g.
`+app.use('/users', userRoutes)+`). +
• Call `+app.listen(port, async (err) => { … })+`. +
– Inside this callback, initialize the database. +
– On failure, log the error and exit the process. +
– On success, log “Server is running on port X”.
. Routing and controllers +
• All requests to `+/users+` go to your *userRoutes* module. +
• Each route handler calls the appropriate function in
*userController.js*. +
• Controllers in turn use *userModel.js* to interact with the database
(e.g. inserting a new user).

By structuring it this way: 

• We only initialize the DB once the server is confirmed up. +
• We support configurable ports out of the box. +
• Our `route → controller → model` flow stays clean and predictable.

== Using Inline Chat For Editing Validation Code

Here’s a more polished, step-by-step summary of how we improved our
user-creation and login flows with proper validation:

[arabic]
. Identify Where to Validate +
• Instead of lumping everything into the low-level utility function, we
chose the UsersController’s `+createUser+` (signup) method—where request
data is first extracted—as the right place to validate. +
• For login, we only need minimal checks (to avoid blank inputs) since
credentials get verified later.
. Define Our Validation Rules +
• Email +
– Must not be empty or just whitespace (hence `+.trim()+`). +
– Must match a standard email-format regex. +
– Must be unique in the database (no existing user with that email). +
• Password +
– Must not be empty or just whitespace. +
– Must be at least six characters long.
. Use Inline AI-Powered Editing +
• We highlighted the entire signup method. +
• We invoked our editor’s inline chat (Cursor) and told it: “Add robust
email and password validation per the rules above.” +
• The AI inserted: +
– `+const email = req.body.email?.trim()+` and
`+const password = req.body.password?.trim()+` +
– Checks for empty strings after trimming. +
– A regex test for valid email format, returning a 400 error if it
fails. +
– `+User.findOne({ email })+` to enforce uniqueness, returning a 409 if
already taken. +
– A length check on the password, returning a 400 if it’s under six
characters.
. Tweak the Login Endpoint +
• For `+/login+`, we similarly ensure `+email.trim()+` and
`+password.trim()+` aren’t empty. +
• We skip stricter checks here, trusting the authentication routine to
handle format and credential validation.
. Next Steps +
• We’re still storing passwords in plain text—for now. +
• Our immediate goal is to get these validations in place and test the
flow. +
• After confirming that requests are properly vetted, we’ll add hashing
(e.g., with bcrypt) and any additional safeguards.

Key Takeaways

• Inline AI-assistant tools can speed up repetitive editing tasks
(regex, trimming boilerplate, etc.). +
• Don’t let AI make every decision for you—stay in the driver’s seat. +
• Always validate at the boundary (where external input enters your
system).

== Testing the REST API With Postman

Here’s a cleaned-up, step-by-step guide for running your server, testing
the signup endpoint with Postman, and spotting the plain-text password
issue:

[arabic]
. Start the Development Server +
• In your project folder run: +
`+npm run dev+` +
• This launches your Express app on http://localhost:3000.
. Install & Launch Postman +
• Download the free Postman desktop app (no account required to test
APIs). +
• Open Postman and click “New Request.”
. Configure the Signup Request +
• Method: POST +
• URL: http://localhost:3000/users/signup +
• Body: +
– Select “raw” +
– Choose “JSON” +
– Enter a JSON object, for example: +
`+json { "email": "test@example.com", "password": "test123abc" } +`
. Send & Verify the Response +
• Click “Send.” +
• You should receive a 200 OK (or 201 Created) with a message like: +
`+{"message":"User created successfully","user":{"id":1,"email":"test@example.com"}}+`
. Inspect the SQLite Database +
• A file named `+database.sqlite+` appears in your project root. +
• To view its contents, install a SQLite viewer (e.g. VS Code’s SQLite
extension). +
• Confirm that the `+users+` table contains your new record.
. Security Warning: Plain-Text Passwords +
• Right now, passwords are stored unhashed in the database. +
• If an attacker ever accessed your database file, they’d see every
user’s password. +
• Always hash passwords before saving—e.g., using bcrypt—so stored
passwords can’t be read directly.

Next Steps +
• Update your signup handler to hash `+req.body.password+` before
inserting into SQLite. +
• Re-run your tests to confirm passwords are now stored safely as
encrypted hashes.
