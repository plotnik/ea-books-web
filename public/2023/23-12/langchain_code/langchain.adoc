= 23-12 Generative AI with LangChain
:source-highlighter: coderay
:icons: font
:toc: right
:toclevels: 4
Ben Auffarth

== 1. What Is Generative AI?

Text generation models such as GPT-4 are advanced tools capable of producing coherent and grammatically correct text across various languages and formats. These models have significant applications in content creation and natural language processing (NLP), striving to achieve algorithms that understand and generate human-like text.

Language models predict the next element in a sequence, helping encode the rules of language in a machine-readable format. They are vital for NLP tasks including content creation, translation, summarization, and text editing.

Representation learning is a key concept where models autonomously learn to represent data to perform tasks without explicit feature engineering. This approach is used in various applications like image recognition, where models learn to identify visual features.

Language models like GPT-4 have been employed in diverse tasks such as essay writing, coding, translation, and genetic sequence analysis. They are utilized in:

- Question answering for efficient customer support through AI chatbots.
- Automatic summarization for quick understanding of lengthy texts.
- Sentiment analysis to gauge customer opinions for businesses.
- Topic modeling to uncover themes in document collections.
- Semantic search to enhance search relevance through NLP.
- Machine translation to aid businesses in international markets, with some models reaching the efficiency of commercial products like Google Translate.

Despite their advancements, language models have limitations in complex reasoning tasks and are prone to generating plausible but false information, known as hallucinations. The potential of increasing model scale to achieve new reasoning capabilities is still uncertain.

---

Large Language Models (LLMs), such as ChatGPT, are sophisticated deep neural networks that excel in language comprehension and generation. These models, including transformers and Generative Pre-Trained Transformers (GPTs), have been trained on vast amounts of text data to learn language patterns through both unsupervised and supervised learning methods. The most recent models, like GPT-4, are capable of multiple modalities, including image processing, and have been trained on trillions of tokens. Despite their abilities, LLMs can produce incorrect or nonsensical answers, a phenomenon known as hallucination.

The article mentions the evolution of LLMs from BERT to GPT-4 in terms of size, training budget, and the organizations involved. OpenAI's GPT series has been at the forefront of LLM development, with GPT-3 having 175 billion parameters and GPT-4 rumored to have between 200 and 500 billion. The cost of training such models is substantial, with GPT-4's training allegedly exceeding $100 million. OpenAI has utilized a Mixture of Experts model to keep costs reasonable and potentially applied speculative decoding to speed up processing, though this could affect quality.

GPT-4 has been trained on a massive scale and can handle complex tasks more effectively, including avoiding harmful responses. It also has a multi-modal version capable of interpreting images and videos. The graph provided in the content shows various LLMs, indicating that there are several models available besides OpenAI's, some of which could serve as alternatives to OpenAI's proprietary models.

---

OpenAI’s GPT-4 is a leading model in the field of generative transformer-based language models, but there are other significant models like Google DeepMind’s PaLM 2 and Meta AI's LLaMa series that also demonstrate strong performance in various tasks.

PaLM 2, released in May 2023, focuses on better multilingual and reasoning capabilities with improved computational efficiency. Though smaller than its predecessor, PaLM 2 excels in tasks like language proficiency exams across several languages and shows enhanced abilities in multilingual common sense, mathematical reasoning, and coding.

The LLaMa and LLaMa 2 series from Meta AI, released in February and July 2023 respectively, have spurred a wave of open-source language model developments. LLaMa 2 has expanded on the original by increasing its training data, context length, and adopting new attention mechanisms. It offers multiple model sizes and is available for both research and commercial use.

Anthropic's Claude and Claude 2 AI assistants are also notable, with Claude 2 emerging as a strong competitor to GPT-4. Released in July 2023, it has shown improvements in helpfulness and a reduction in bias, and it performs well in areas like coding and summarization.

Although all these models have made significant strides, they still share limitations like potential biases, factual inaccuracies, and the capacity for misuse, which their developers are actively working to mitigate. The evolution of large language models remains concentrated among a few key players due to the high computational demands of developing and training such models.

---

This passage discusses the development and deployment of large language models (LLMs) by various companies and institutions. Training such models requires immense computational resources and expertise, with costs ranging from $10 million to over $100 million. Meta's LLaMa 2 model, with 70 billion parameters, and Google's PaLM 2 model, with 340 billion parameters, are examples of LLMs trained on extensive datasets in multiple languages.

Few organizations have the capability to train and deploy very large models; notable contributors include tech giants like Microsoft and Google, as well as universities like KAUST and Carnegie Mellon. Collaborations between companies and universities have resulted in projects like Stable Diffusion, Soundify, and DreamFusion.

Several entities are developing generative AI and LLMs, with varied approaches to sharing their work:

- **OpenAI** released GPT-2 as open source but has since restricted access to later models, offering them through an API.
- **Google** and **DeepMind** have created models such as BERT and PaLM, with some initially open-sourced but more recent development being more secretive.
- **Anthropic** offers public usage of its Claude models through their website, with API in private beta.
- **Meta** has released models like RoBERTa and LLaMa 2, including parameters and setup code, often under non-commercial licenses.
- **Microsoft** has developed its own models but also integrates OpenAI models into its products, releasing some parameters for research.
- **Stability AI**, the creator of Stable Diffusion, released model weights under a non-commercial license.
- **Mistral**, a French startup, offers a free, open-license 7B model.
- **EleutherAI** provides fully open-source models like GPT-Neo and GPT-J to the public.
- Companies like **Aleph Alpha**, **Alibaba**, and **Baidu** prefer providing API access or integrating models into products rather than releasing their training code or parameters.

Additionally, the **Technology Innovation Institute** has open-sourced its Falcon LLM for research and commercial use.

Despite the high computational costs, the release of models like LLaMa has enabled smaller companies to make significant advancements, particularly in coding capabilities.

---

The provided text discusses the transformative impact of the Transformer deep neural network architecture on natural language processing (NLP), particularly with the advent of models like BERT and GPT. This architecture, introduced in the paper "Attention Is All You Need" by Vaswani et al. in 2017, differs from previous models by processing words in parallel rather than sequentially, allowing for more efficient computation.

Transformers consist of an encoder and decoder, each comprising multiple layers with attention mechanisms and feed-forward networks. These models use positional encoding to retain information about word order, layer normalization for stable learning, and multi-head attention to capture different aspects of information simultaneously.

Attention mechanisms, a key feature of transformers, involve computing weighted sums of values based on the similarity between positions in the input sequence. Multi-Query Attention (MQA) is an extension that enhances efficiency, used in models such as OpenAI's GPT series.

Grouped-Query Attention (GQA) is another technique used to speed up attention computation by caching key and value pairs, although it has memory cost issues with larger contexts or batch sizes.

Other efficiency-increasing methods include sparse and low-rank attention, latent bottlenecks, and architectures like transformer-XL which use recursion to store and leverage hidden states of previously encoded sentences.

The majority of large language models (LLMs) are based on the Transformer architecture due to its effectiveness in understanding and generating human language, as well as applications in other domains like image, sound, and 3D object processing.

The text concludes by mentioning that GPT models, which dominate the landscape of LLMs, are characterized by their pre-training process, setting the stage for a discussion on how these models are trained.

---

The transformer model is trained in two stages: unsupervised pre-training and task-specific fine-tuning. Pre-training's objective is to learn a universal representation for various tasks. Masked Language Modeling (MLM) is a pre-training method where the model predicts missing words in a sentence. The model's parameters are updated to minimize the difference between its predictions and the actual tokens.

Two key metrics for training and evaluating language models are Negative Log-Likelihood (NLL) and Perplexity (PPL). NLL measures the probability of correct predictions, with lower values indicating better learning. PPL, which is the exponentiation of NLL, provides a more intuitive measure of model performance; a lower PPL suggests a model that accurately predicts words and is "less surprised" by the next word.

Perplexity is used to compare performance across different language models, where a lower value signifies a more effective model. The training process begins with tokenization, which converts words to numerical representations necessary for the model to process the input.

---

Tokenization is the process of breaking down text into smaller units called tokens, which can be words, subwords, punctuation marks, or numbers. These tokens are then converted into unique numerical IDs through a mapping dictionary. The dictionary is created from the training data before training a Large Language Model (LLM) and remains unchanged afterward.

The numerical IDs assigned to tokens are not random; they are within a specific range, determined by the size of the tokenizer's vocabulary. Tokens are essential for constructing sequences of text during the processing of natural language.

Different tokenization methods like Byte-Pair Encoding (BPE), WordPiece, and SentencePiece are used in various models. For instance, LLaMa 2's BPE tokenizer breaks numbers into single digits and decomposes unknown UTF-8 characters using bytes, with a total vocabulary size of 32,000 tokens.

LLMs have a context window that limits the length of the token sequence they can process, usually ranging from 1,000 to 10,000 tokens. The large scale of these models is briefly mentioned as a topic for further discussion.

---

The content discusses the trend of increasing language model sizes in machine learning, referencing a figure that shows their growth over time. This trend is linked to the decrease in computing costs and the pursuit of higher performance. Key findings from various research papers are highlighted:

- A 2020 paper by Kaplan et al. from OpenAI analyzed scaling laws for neural language models and found that transformers outperform LSTMs in handling long contexts, which leads to better performance and efficiency.
- The paper also established a power-law relationship between a model's performance and the dataset size, model size, and computational resources, suggesting that these factors should be scaled together to avoid performance bottlenecks.
- DeepMind researchers in 2022 suggested that large language models (LLMs) are undertrained relative to what scaling laws would recommend for compute budget and dataset size. They showed that a smaller model (Chinchilla) could outperform a larger one (Gopher) if trained longer with a proportional dataset.
- Contrary to the trend of larger models, Microsoft Research's recent study found that a smaller network (350M parameters) trained on high-quality data can perform competitively, challenging the notion that bigger is always better.
- Future chapters of the source will explore the implications of scaling laws for generative models and the potential for new scaling laws related to data quality.
- Lastly, the content mentions that after pre-training, models are prepared for specific tasks through fine-tuning or prompting, which will be discussed in the context of task conditioning.

---

Conditioning Large Language Models (LLMs) involves adapting them for specific purposes, and it can be achieved through fine-tuning and prompting:

- **Fine-tuning** is the process of further training a pre-trained LLM on a specific dataset to improve its performance on a particular task. This can include instruction tuning, where the model learns to follow natural language instructions, and Reinforcement Learning from Human Feedback (RLHF), which aims to make the model more helpful and safe.

- **Prompting techniques** involve providing the model with text-based problems to solve. These can range from simple questions to complex instructions, and may or may not include examples. Zero-shot prompting doesn't use examples, while few-shot prompting provides a few example problems and solutions to guide the model.

---

The provided content explains how to access OpenAI's model and other language models (LLMs) through their website, API, or platforms like Hugging Face. Open-source LLMs can be downloaded, fine-tuned, or fully trained, with a guide to fine-tuning provided in Chapter 8 of the referenced book. It also mentions the use of generative AI in creating 3D images, avatars, and other graphical content, with a focus on text-to-image generation. The book will primarily discuss LLMs due to their wide-ranging applications but will also touch upon image models. Upcoming sections will review state-of-the-art methods for text-conditioned image generation, including progress, challenges, and future directions.

---

Text-to-image models are AI systems that generate images from textual descriptions. They are used in various fields, such as art, design, and advertising, to create visuals based on textual prompts. The models employ techniques like diffusion processes, where they start with a random noise and refine it into an image. They also use text encoders to convert text into embeddings, which are then processed in successive stages to produce images.

There are two main types of models: Generative Adversarial Networks (GANs) and diffusion models. GANs consist of two competing networks, a generator and a discriminator, which improve over time to create realistic images. Diffusion models work by gradually denoising a noisy image until it becomes a coherent picture corresponding to the text prompt.

Stable Diffusion is a notable example that operates in latent space, which is more computationally efficient than pixel space. It uses a Variational Autoencoder (VAE) for compression and a U-Net architecture for denoising. Stable Diffusion has been made available publicly under an open license, allowing wide access and use on consumer-grade hardware.

The training for these models is done on large datasets, and images are generated through a series of steps, including encoding, denoising, and decoding. The models can also be conditioned with specific inputs like depth maps or outlines to create images that closely match the text prompts.

These AI capabilities also extend to other domains beyond image generation, but the provided content focuses on the text-to-image context.

== 2. LangChain for LLM Apps

LLMs (Large Language Models) are powerful tools for language processing but have notable limitations, which need to be understood when they are employed in applications:

1. **Outdated Knowledge**: LLMs are trained on historical data and cannot update their knowledge without new training, leaving them unaware of recent events or developments.
2. **Inability to Take Action**: LLMs are not capable of performing interactive actions such as web searches or data retrieval, which limits their practical use.
3. **Lack of Real-Time Context**: They struggle with understanding context from previous interactions, and cannot incorporate new context without external data sources.
4. **Hallucination Risks**: LLMs may generate inaccurate or nonsensical responses when they lack concrete information on a topic.
5. **Biases and Discrimination**: The biases present in their training data can lead to biased outputs, which reflect religious, ideological, or political prejudices.
6. **Lack of Transparency**: The complexity of LLMs can make their decision-making process opaque and not easily understandable.
7. **Memory Limitations**: LLMs may not remember details from earlier parts of a conversation or struggle to provide relevant additional information.

To illustrate these limitations, the author provides examples where an LLM:

- Lacks up-to-date information about a query concerning LangChain, potentially leading to incorrect responses about a different entity with the same name.
- Performs inconsistently in solving math problems, correctly answering one question but failing another, highlighting the LLM's reliance on training data rather than computational ability.
- Could face problems with reasoning, such as determining whether a fruit would float based on its density compared to water, due to difficulties in synthesizing information.

The challenges posed by these limitations can be addressed by integrating LLMs with external data sources, analytical tools, and other applications to provide real-world context and enhance functionality. However, careful design and monitoring are required to mitigate risks such as bias and inappropriate content.

---

The excerpt discusses various techniques to improve the performance and reliability of large language models (LLMs), which include:

- **Retrieval augmentation**: Enhancing model responses with information from knowledge bases to provide current context and reduce false information.
- **Chaining**: Allowing the model to perform searches and calculations as part of its response process.
- **Prompt engineering**: Designing prompts that include critical context to steer the model towards appropriate responses.
- **Monitoring, filtering, and reviews**: Implementing continuous oversight to identify and correct issues with the model’s inputs and outputs through:
    1. Automated **filters** like block lists and sensitivity classifiers.
    2. Monitoring based on **constitutional principles** to ensure ethical content.
    3. **Human reviews** to gain insights into the model’s behavior and outputs.
- **Memory**: Maintaining the context of conversations over time.
- **Fine-tuning**: Adapting the model with data that's more relevant to its intended use to align with application-specific requirements.

The text emphasizes that merely increasing a model's size does not grant it advanced reasoning skills. Instead, explicit strategies like prompting and chain-of-thought reasoning are necessary for compositional tasks. Techniques like self-ask prompting encourage the model to break down complex problems methodically.

The integration of these tools into training helps bridge gaps in the model’s abilities, where prompting provides context, chaining allows for logical inference, and retrieval adds factual data. This turns basic LLMs into more sophisticated reasoning tools.

Proper prompt engineering and fine-tuning are essential for preparing models for practical applications, while continuous monitoring ensures any problems are promptly addressed. Filters serve as an initial safeguard, and adherence to AI constitutional principles aims to ensure ethical behavior.

Connecting LLMs to external data sources is important for maintaining accuracy and reducing the generation of false information (hallucination), although it adds complexity to the system. Frameworks like LangChain offer a structured approach to responsibly use LLMs by enabling the combination of model queries with data sources, thus overcoming the limitations of standalone LLMs. The text suggests that with these enhancements, it is possible to create AI systems that were not feasible before due to inherent model limitations, setting the stage for further discussion on the topic.

---

Large Language Models (LLMs), when integrated with specialized tools into applications, can significantly impact the digital landscape. These applications often involve a series of prompted interactions with LLMs, sometimes supplemented with external services or data sources to complete tasks.

Traditional software applications follow a multi-layer architecture with distinct client, frontend, backend, and database layers. In contrast, an LLM app uses an LLM to understand and respond to natural language prompts, including a client layer for user input, prompt engineering to guide the LLM, an LLM backend for processing, an output parsing layer, and optional integration with external services.

LLM apps can be enhanced with functions such as API access, advanced reasoning algorithms, and retrieval augmented generation (RAG) which weaves in external knowledge for more robust capabilities. These extensions enable LLM apps to execute complex logic chains, interact with databases conversationally, and provide dynamic responses based on up-to-date information.

The advantages of LLM applications include nuanced language processing, personalization, contextualization, and the ability to perform multi-step inferences. They facilitate natural user interactions and can be developed more efficiently since they do not require manual coding for every language scenario.

However, responsible data practices are crucial to address concerns around privacy, security, and potential misuse. LLM applications can be applied in various domains, such as chatbots, intelligent search engines, automated content creation, question answering, sentiment analysis, text summarization, data analysis, and code generation.

The effectiveness of LLMs is amplified when they are combined with other knowledge sources and computational tools. The LangChain framework is designed to integrate LLMs with other components to build complex, reasoning-based applications, addressing challenges associated with LLMs and enabling the creation of customized NLP solutions.

---

LangChain is an open-source Python framework created by Harrison Chase in 2022, designed to ease the development of applications powered by large language models (LLMs). It provides a modular structure that allows developers to integrate language models with external data sources and services. Sequoia Capital and Benchmark, known for funding major tech companies, have invested in LangChain.

The framework offers reusable components and pre-assembled chains to streamline the creation of complex LLM applications. It addresses common challenges in LLM application development, such as prompt engineering, bias mitigation, and integrating external data, by providing abstracted and composable tools.

LangChain also supports advanced features like conversational context, persistence through agents and memory, and the ability to interact more sophisticatedly with the environment. Its key benefits include its modular design, chaining capabilities, memory and persistence for stateful interactions, and the open-source community.

Although LangChain is primarily a Python-based framework, there are companion projects in JavaScript (LangChain.js) and Ruby (`Langchain.rb`). Development of LLM applications can be challenging, but resources like documentation, courses, communities, and a Discord server are available to support developers.

An ecosystem is growing around LangChain, with extensions and integrations being regularly added. LangSmith offers debugging, testing, and monitoring tools for LLM apps. LlamaHub and LangChainHub provide libraries for building LLM systems, with LlamaHub focusing on data integration and LangChainHub serving as a repository for sharing LangChain artifacts.

Additionally, LangFlow and Flowise are UIs that facilitate the visual assembly of LangChain components into executable workflows. LangChain can be deployed locally or on various platforms, and `langchain-serve` streamlines deployment on the Jina AI cloud.

The framework aims to simplify the development process for more advanced LLM applications by leveraging its modular components, including memory, chaining, and agents.

---

The passage discusses the concept of "chains" in LangChain, which are sequences of calls to components that can be used to build complex applications. Chains can include various components, such as language model calls, mathematical tools, and database queries, and are designed to be modular, composable, and reusable. They can be used to improve LangChain application performance by chaining prompts together or integrating specific tools, and they can enforce policies to moderate content or align with ethical standards.

For example, the `LLMCheckerChain` is used to verify statements and reduce inaccurate responses, a technique supported by a research paper which showed a 20% improvement in task performance. Router chains can autonomously decide which tool to use for a given task.

Benefits of using chains include modularity, composability, readability, maintainability, reusability, easy tool integration, and productivity. Creating a chain typically involves breaking down a workflow into logical steps and ensuring that components are single-responsibility and stateless for maximum reusability. Customizable configurations, robust error handling, and monitoring/logging are essential for creating reliable chains.

---

Agents in LangChain are self-governing software entities designed to perform tasks and achieve specific goals through interaction with users and environments. They are distinct from chains, which are sequences of components that execute logical steps. Agents use chains by orchestrating them to take actions based on goals. They make decisions on actions by using large language models (LLMs) as reasoning engines, which process the available tools, user input, and past actions to determine the next step or final response.

Tools are essential functions that agents utilize to interact with the real world, and the agent executor runtime manages the continuous cycle of querying the agent, performing tool actions, and incorporating feedback from the environment, while handling technical details like error management and parsing.

The main advantages of agents include goal-driven behavior, the ability to dynamically adjust to environmental changes, maintaining context through statefulness, robust error handling through alternatives, and the composition of reusable chains.

Agents enable complex, multi-step tasks and interactive applications such as chatbots. They are designed to select and use the appropriate tools, as exemplified by an agent choosing to use a calculator or Python interpreter for calculations, indicating that sometimes simpler tools are more effective than complex LLMs for specific tasks.

However, agents and chains typically operate without retaining context from one execution to the next, presenting a limitation in statelessness. To address this, LangChain introduces memory components that allow information to be carried over between executions, enabling agents to maintain state and context.

---

LangChain's concept of memory allows for the persistence of state between executions of a chain or agent, enhancing the development of conversational and interactive applications. Memory enables the storage of conversational contexts, facts, relationships, and task progress, which improves response coherence and relevance, provides consistency, and maintains contextual information across sessions. This memory system reduces redundant LLM calls, saving on API costs and maintaining necessary context for the agent or chain.

LangChain offers a standard memory interface and various storage integrations, including databases. Some of the memory options provided are:

- `ConversationBufferMemory` for full message history storage, though it increases latency and costs.
- `ConversationBufferWindowMemory` for retaining only recent messages.
- `ConversationKGMemory` for summarizing exchanges into a knowledge graph.
- `EntityMemory` for persisting agent states and facts, often backed by a database.

There are multiple database options available for durable storage, such as SQL databases (e.g., Postgres, SQLite), NoSQL databases (e.g., MongoDB, Cassandra), in-memory databases like Redis, and managed cloud services like AWS DynamoDB. Specialized memory servers like Remembrall and Motörhead are also available for optimized conversational context.

The choice of memory approach depends on specific requirements such as persistence needs, data relationships, scalability, and resources. Effective memory patterns are crucial for creating stateful, context-aware agents, and LangChain provides the tools and integrations necessary to build such advanced AI systems.

---

LangChain provides a framework for integrating external services, such as databases and APIs, into language models, enhancing their capabilities beyond simple text processing. Tools within LangChain offer various functionalities, including document loading, indexing, and data storage, and can be organized into toolkits that share resources. These tools can be combined with language models to address a wide range of tasks:

- **Machine translator**: Helps models understand and respond in multiple languages.
- **Calculator**: Performs basic arithmetic operations.
- **Maps**: Provides location-based services, routing, and points of interest information.
- **Weather**: Supplies real-time weather data for various locations.
- **Stocks**: Accesses stock market data for financial analysis.
- **Slides**: Assists in creating presentation slides based on high-level semantics.
- **Table processing**: Analyzes and visualizes tabular data using data manipulation APIs.
- **Knowledge graphs**: Facilitates querying of structured factual data.
- **Search engine**: Enhances web-based information retrieval.
- **Wikipedia**: Aids in searching and disambiguating Wikipedia content.
- **Online shopping**: Enables e-commerce functionalities like product searching and selection.

Additional tools include AI Painting for image generation, 3D Model Construction for creating 3D visuals, Chemical Properties for scientific inquiries, and database tools for interacting with databases using natural language.

These tools significantly expand the applications of language models, allowing them to perform various specialized tasks efficiently. 

---

LangChain is a framework designed to build applications using large language models (LLMs) by providing modular components for various tasks. It enables the creation of pipelines, also known as chains, to perform sequences of actions such as loading documents, embedding for retrieval, querying LLMs, parsing outputs, and writing to memory. These components can be mixed and matched to align with specific application goals.

Key components of LangChain include:

- Interfaces for interacting with LLMs and chat models, supporting asynchronous, streaming, and batch operations.
- Document loaders for ingesting data from various sources into text and metadata.
- Document transformers for adapting data through manipulation like splitting, combining, and filtering.
- Text embedding models for creating vector representations of text to facilitate semantic search.
- Vector stores for indexing document vectors to improve retrieval efficiency.
- Retrievers to return relevant documents based on a query.
- Tools for interacting with external systems such as databases or web searches.
- Agents that are goal-driven systems using LLMs to plan and execute actions.
- Toolkits to initialize groups of tools sharing resources.
- Memory components to maintain conversation and workflow information across sessions.
- Callbacks for integrating with pipeline stages for tasks like logging and monitoring.

The framework offers standardized interfaces for integrating with various language model providers, allowing for easy swapping of models depending on cost, energy efficiency, or performance needs. It also provides prompt classes for user interaction with LLMs, which can be optimized through prompt engineering, and a collection of templates and battle-tested prompts.

LangChain supports a variety of data types and includes utilities for external system interaction, with the aim to enhance LLMs' knowledge and performance in applications like question answering and summarization. It also offers numerous integrations for vector storage, facilitating efficient document retrieval even for large documents.

For more detailed information, the LangChain API reference and code examples are available online. LangChain stands out as a comprehensive and feature-rich framework for building LLM applications.

---

This text discusses the landscape of application frameworks designed for large language models (LLMs), with a focus on open-source libraries in Python for building dynamic LLM applications. It compares the popularity of various frameworks using GitHub stars over time, referencing a graph that illustrates their relative growth.

The frameworks mentioned include:

- **Haystack**: The oldest framework mentioned, which started in early 2020 and is focused on creating large-scale search systems. Despite its early start, it is the least popular among those discussed.
- **LangChain**: A rapidly growing framework that specializes in chaining LLMs together using agents, prompt optimization, and context-aware information retrieval/generation. It is praised for its modular interface and comprehensive toolset.
- **LlamaIndex (previously GPTIndex)**: Aimed at advanced retrieval tasks rather than a broad range of LLM applications.
- **SuperAGI**: Offers features similar to LangChain, including a marketplace for tools and agents, but it is not as extensive or well-supported.
- **AutoGen**: A Microsoft project that facilitates the creation of workflows powered by LLMs, particularly through customizable conversational agents that automate coordination between LLMs, humans, and tools.

The text also references AutoGPT and other tools focused on prompt engineering, such as Promptify, but notes their limitations in reasoning and tendency to fall into logic loops. Additionally, it mentions frameworks in other programming languages, like Dust in Rust, which is geared towards the design and deployment of LLM apps.

The author emphasizes the importance of foundational knowledge in leveraging LLM frameworks effectively and responsibly, and suggests that investment in education is crucial to develop capable LLM applications.

== 3. Getting Started with LangChain

The provided text describes the use of a fake LLM (Large Language Model) in testing environments to simulate responses from a real LLM without making actual API calls. This allows developers to rapidly prototype and test their applications without being constrained by rate limits or the need for a live LLM. The fake LLM can be used for mocking various responses to ensure that an application handles them correctly, thus facilitating quick iteration.

The text includes a simple example of initializing a `FakeLLM` in Python that returns a single response "Hello". It also provides a more complex example using `FakeListLLM` to mock a sequence of responses within an agent framework that leverages tools like a Python REPL. This is used to demonstrate how an agent can interact with a tool based on the fake LLM's output. The agent in this example is set up to react to input text ("what's 2 + 2") and, through the fake LLM's responses, perform an action (running Python code via REPL) and return a result ("Final Answer: 4").

The text highlights that the action performed by the agent must match the `name` attribute of the tool, which in this example is "Python_REPL". The fake LLM can be programmed to return a different final answer, which would not be consistent with the actual computation.

---

To use OpenAI's API, it is necessary to obtain an API key, and the text provides a step-by-step guide on how to do this, including creating a login, setting up billing, and generating a new key on the OpenAI platform. A Python code snippet is also given, showing how to set up an OpenAI language model class and create an agent that can perform calculations. An example demonstrates the agent correctly solving a simple arithmetic problem.

---

Hugging Face is a leading company in the field of natural language processing (NLP), known for its open-source contributions and machine learning hosting services. It is based in the United States and is responsible for creating the widely-used Transformers Python library, which supports NLP models like Mistral 7B, BERT, and GPT-2, while being compatible with PyTorch, TensorFlow, and JAX.

The company also operates the Hugging Face Hub, an online platform with over 120,000 models, 20,000 datasets, and 50,000 demo applications (spaces) that serves as a collaborative environment for machine learning practitioners. Their ecosystem includes other libraries such as `Datasets` for managing datasets, `Evaluate` for model evaluation, `Simulate` for running simulations, and `Gradio` for creating machine learning demos.

Hugging Face has engaged in significant research initiatives, such as the BigScience Research Workshop and the release of the BLOOM model, which has 176 billion parameters. They have secured substantial funding, with a Series C round valuing the company at $2 billion, and have formed partnerships with industry giants like Graphcore and AWS.

Users can access and integrate Hugging Face models into their applications by creating an account and obtaining API keys. For example, using the Flan-T5-XXL model developed by Google, one can run NLP tasks like answering questions, as demonstrated in the provided Python code snippet.

---

Google Cloud Platform offers access to various machine learning models and functions through Vertex AI, with language models such as LaMDA, T5, and PaLM available. The Natural Language API has been updated with a new large language model for Content Classification, featuring over 1,000 labels and supporting 11 languages.

To use models on GCP, one must install the `gcloud` command-line interface and authenticate using the provided command. Vertex AI must be enabled for the project, which involves installing the Google Vertex AI SDK.

Setting up the Google Cloud project ID can be done in multiple ways, including using `gcloud`, passing a constructor argument, using `aiplatform.init()`, or setting a GCP environment variable.

Running a model involves using the VertexAI class and LLMChain with a PromptTemplate. The provided example demonstrates running a query about which NFL team won the Super Bowl in the year Justin Bieber was born, with a step-by-step reasoning approach. The response correctly identifies the San Francisco 49ers as the winners in 1994, despite a misspelling of Bieber's name.

Vertex AI has specialized models for various tasks, such as following instructions, conversation, and code generation. Models like text-bison, chat-bison, code-bison, codechat-bison, and code-gecko have different token limits and are designed for specific use cases.

The example also shows the code-bison model generating a Python function to solve the FizzBuzz problem, suggesting the model's capability to generate functional code for common programming tasks. The documentation provides more detailed and current information about the models and their updates.

---

Jina AI is an AI company based in Berlin that provides cloud-native neural search solutions for various data types, including text, image, audio, and video. The company, founded in 2020, has developed an open-source neural search ecosystem to help developers create scalable and efficient information retrieval systems. They also introduced a tool called Finetuner for fine-tuning deep neural networks according to specific needs.

The company has raised $37.5 million through funding rounds, with significant investment from GGV Capital and Canaan Partners. Jina AI offers an API platform for setting up services like image captioning and visual question answering.

The document includes an example of setting up a Visual Question Answering API and a guide to using Jina AI's services with LangChain, a library that facilitates working with language models. Although Jina AI APIs are not directly available through LangChain, users can integrate them by subclassing the `LLM` class. Instructions on setting up a chatbot with Jina AI are provided, along with examples of API calls for translation and food recommendation tasks.

The document distinguishes between LLMs (text completion models) and chat models (designed for conversational interactions) in LangChain, noting that both implement a base language model interface allowing for versatility in application usage.

=== 3.4. Building an application for customer service

Generative AI can greatly assist customer service agents by classifying customer sentiment, summarizing lengthy messages, predicting customer intent, and suggesting answers to improve response accuracy and timeliness. LangChain facilitates the use of various models, including those from Hugging Face, for tasks like sentiment analysis and summarization. For instance, sentiment analysis can identify negative or positive emotions in customer communications, while summarization tools condense lengthy texts. Popular models on Hugging Face for these tasks include `distilbert-base-uncased-finetuned-sst-2-english` for sentiment classification and `facebook/bart-large-cnn` for summarization. The use of AI in customer service can help with the quick resolution of common issues, allowing human agents to focus on complex problems, thereby enhancing customer service efficiency and effectiveness.

==== Summarizing with Chain of density

Missing entities:: Generative AI; LangChain; Hugging Face integrations; sentiment analysis; summarization; intent classification; Zengzhi Wang; Financial PhraseBank; ProsusAI/finbert; Python code; Vertex AI; Prototype; Chapter 5; Chatbot; GPT-3.5; GitHub; spaCy; Cohere; NLP Cloud; LLMs; few-shot prompts; pipeline; `HuggingFaceHub`; `load_huggingface_tool()`; `cardiffnlp/twitter-roberta-base-sentiment`; emoji prediction; irony detection; hate speech detection; offensive language identification; stance detection; `LABEL_0`; facebook/bart-large-cnn; t5-small; t5-base; sshleifer/distilbart-cnn-12-6; t5-large; `HUGGINGFACEHUB_API_TOKEN`; PromptTemplate; LLMChain; graphical interface; AI automation; customer service workflows

Generative AI tools like LangChain can enhance customer service by offering sentiment analysis, summarization, and intent classification. Integrations with platforms like Hugging Face provide access to specialized models, such as ProsusAI/finbert for financial text. Python code examples demonstrate how to use these tools, highlighting their application in a prototype for a chatbot in Chapter 5. For instance, GPT-3.5 generated a customer email complaint, available on GitHub, which was analyzed using spaCy, Cohere, and NLP Cloud models. Using few-shot prompts, LLMs can be executed through a pipeline or via `HuggingFaceHub` and `load_huggingface_tool()` loaders. The `cardiffnlp/twitter-roberta-base-sentiment` model, capable of emoji prediction, irony detection, hate speech detection, offensive language identification, and stance detection, identified the email's sentiment as negative (`LABEL_0`). The `facebook/bart-large-cnn` is among the most downloaded summarization models on Hugging Face, along with t5 variants. With `HUGGINGFACEHUB_API_TOKEN`, the model can summarize text remotely. Vertex AI is also showcased, where a PromptTemplate and LLMChain identified the email's category. The potential for AI automation in customer service workflows is evident, and a graphical interface can be implemented for agents to interact with AI-enhanced systems.

==== Summarizing with LangChain Map-Reduce

Generative AI can enhance customer service by assisting agents with tasks such as sentiment classification, summarization, and intent classification, leading to more personalized and efficient service. LangChain allows the use of various AI models, including those from Hugging Face, for these purposes. The text illustrates how AI can interpret customer sentiment, summarize communications, and categorize issues, suggesting that AI could manage routine inquiries and free up human agents for complex problems. The integration of AI tools into a user-friendly interface for agents is proposed for future exploration.

== 4. Building Capable Assistants

=== 4.1. Mitigating hallucinations through fact-checking

The text discusses the issue of hallucination in Large Language Models (LLMs), where generated text does not accurately reflect the input, leading to misinformation. It emphasizes the importance of fact-checking to maintain information integrity and mitigate societal harm caused by misinformation, such as distrust in science and damage to democratic processes.

The process of automatic fact-checking is described in three stages: claim detection, evidence retrieval, and verdict prediction. The process is demonstrated using a pipeline diagram from a GitHub repository. Pre-trained LLMs with extensive world knowledge from sources like Wikipedia can be prompted to retrieve facts for evidence verification, or external tools can be used to search knowledge bases and other corpora.

A practical application is introduced with the `LLMCheckerChain` in LangChain, which uses prompt chaining to question the assumptions behind statements and check their validity. The model sequentially lists assumptions, checks their truthfulness, and makes a final judgment on the initial question. The example provided shows how this process can be used to verify which mammal lays the largest eggs, demonstrating that while not infallible, the fact-checking approach can improve the reliability of LLMs.

=== 4.2. Summarizing information

[NOTE]
====
Example:: generative_ai_with_langchain/summarize/prompts.py

Web Server:: generative_ai_with_langchain/webserver/chat.py
====

The provided text explains how to use LangChain, a Python library, to summarize text using OpenAI's language models. It describes two methods: a basic approach using prompts and a more Pythonic way using LangChain decorators. The latter offers a cleaner interface, enabling developers to write natural Python code while leveraging the power of language models for tasks such as summarization. An example demonstrates summarizing a piece of text into a one-sentence summary using the `@llm_prompt` decorator.

---

The provided text describes the use of prompt templates in LangChain Expression Language (LCEL) to dynamically insert text into prompts, which is useful for tasks like text summarization. The example code demonstrates how to set up a prompt template and create a chain in LCEL that includes a language model (LLM) and an output parser. The chain is then used to generate a summary of the provided text. LCEL offers benefits such as asynchronous processing, batching, streaming, and other features that enhance productivity and integration.

---

Salesforce researchers have devised a method called Chain of Density (CoD) for GPT-4 that produces increasingly dense and concise summaries by iteratively including more informative entities without extending the length. Using a structured prompt, the process starts with a sparse summary and, through five rounds of editing, integrates additional entities while maintaining word count. This technique enhances the information density of summaries, but there's a balance to strike as too many entities can reduce clarity. The effectiveness of CoD is evaluated through human studies and GPT-4 scoring, highlighting the trade-offs between detail and coherence in AI-generated text.

==== 4.2.4. Map-Reduce pipelines

[NOTE]
====
Jupyter::
my/08_summarize.ipynb

LangChain - Summarization::
https://python.langchain.com/docs/use_cases/summarization

Markdown Loader::
https://python.langchain.com/docs/modules/data_connection/document_loaders/markdown
====

LangChain enables efficient processing of documents using a map-reduce approach with large language models (LLMs). Documents are split into chunks, each summarized in parallel (map step), and then combined and further summarized (reduce step). This method allows for scaling summarization to any text length and can include an optional collapsing step to ensure chunks fit within token limits.

The process involves loading a document, like a PDF, summarizing each part independently, and then combining these summaries into a final, concise document. Custom prompts can be used for different steps to tailor the output, such as summarizing, translating, or rephrasing.

An example in Python demonstrates loading a PDF, summarizing it with a map-reduce chain, and outputting the summary. The approach is customizable, allows parallel processing, and can be used for various applications like literature reviews. However, when using cloud services, this method may increase computational costs due to the number of tokens processed.

==== 4.2.5. Monitoring token usage

When using language models like those from OpenAI, it is crucial to monitor token usage to manage costs. OpenAI offers a variety of models tailored to different tasks, such as ChatGPT for dialogue and InstructGPT for instruction-following, with varying levels of speed and capability, affecting their pricing. For image generation, OpenAI has DALL·E, and for speech transcription and translation, it provides Whisper, each with different pricing structures.

To track token usage and costs, OpenAI provides a callback function in Python that displays the number of tokens used and the associated cost for each operation. Additionally, the `generate()` method and the chat completions response format offer information on token usage. Understanding these costs is essential for managing the budget in production environments. The upcoming chapter will discuss tools that offer further insights into the token usage of generative AI models.

=== 4.3. Extracting information from documents

OpenAI announced updates to their API in June 2023, adding **function calling** capabilities to enhance the interaction with GPT models, specifically `gpt-4-0613` and `gpt-3.5-turbo-0613`. This new feature allows developers to define functions in a schema format which the models can use to return structured outputs, such as JSON objects. This is particularly useful for creating chatbots, converting natural language into API or database queries, and extracting structured data from text.

Developers can define functions using the `functions` parameter in the API and describe them using JSON schema. This enables precise extraction of information, as demonstrated with an example schema for a Curriculum Vitae (CV) using the Pydantic library for parsing.

LangChain, a tool for building LLM applications, can utilize these function calls for tasks such as information extraction from documents. An example code snippet demonstrates how one might extract information from a CV using LangChain’s `create_extraction_chain_pydantic()` function and an OpenAI model.

The result of this extraction process may not be perfect, capturing only a part of the desired information, but it illustrates the potential of this approach. OpenAI's function calling is integrated into the system message and is optimized for their models, which affects the context limit and billing.

LangChain supports function calls natively and can use models from providers other than OpenAI. The chapter also hints at further integrations, allowing LLM agents to execute function calls to connect with live data, services, and runtime environments. The next section is set to discuss how tools can augment context by retrieving external knowledge sources.

=== 4.4. Answering questions with tools

[NOTE]
====
Streamlit:: st_langchain.py
====

LangChain is a platform that enhances the capabilities of large language models (LLMs) by enabling them to interact with external data sources and tools, thus allowing them to perform domain-specific tasks and access real-time information. This functionality is facilitated by a framework of agents and chains that can be developed to include tools like calculators, search engines (like DuckDuckGo and Wolfram Alpha), and information databases (like arXiv and Wikipedia). These tools help LLMs provide more accurate and relevant responses by grounding them in real-world data and reducing incorrect or hallucinated replies.

The integration of LLMs with tools can be demonstrated by setting up an agent in Python, which includes a DuckDuckGo search tool for privacy-focused searches, Wolfram Alpha for math questions, arXiv for academic research, and Wikipedia for information about notable entities. To use Wolfram Alpha, a developer account and token are required.

LangChain can also be used to build interactive web applications using Streamlit, a platform that facilitates the creation of user interfaces for machine learning workflows. An example provided in the text shows how to create a Streamlit app that enables users to interact with a chatbot powered by LangChain. This Streamlit integration allows for real-time updates, easy deployment, and sharing through Streamlit Community Cloud or Hugging Face Spaces.

The text illustrates the process of building a Streamlit app and deploying it, highlighting the advantages of a quick and intuitive user interface that can be tailored to specific use cases. Streamlit apps are responsive and can handle complex workflows, allowing users to interact with the LLM-powered agent with ease. Despite these advancements, the LLM's reasoning abilities are limited, and the text suggests that more advanced types of agents can be implemented to overcome these limitations.

=== 4.5. Exploring reasoning strategies

[NOTE]
====
Streamlit:: st_plan.py
====

Language Large Models (LLMs) are adept at recognizing patterns but have limitations in performing complex multi-step symbolic reasoning. To enhance their capabilities, hybrid systems combining neural pattern recognition and symbolic manipulation are being developed. These advanced systems can perform multi-step deductive reasoning, mathematical problem-solving, and optimized action planning.

Hybrid systems involve various components and architectures such as action agents, which iterate based on new observations, and plan-and-execute agents, which create a full plan before taking action. Action agents use an observation-dependent approach, while plan-and-execute agents involve a Planner to create plans and a Solver to execute the final output after evidence is gathered.

The research application LangChain demonstrates how to implement these reasoning strategies, allowing users to select between zero-shot-react and plan-and-solve strategies. The application uses a combination of tools and LLMs to answer complex questions, and it can be executed using Streamlit, a tool for creating web applications.

The plan-and-solve strategy is particularly efficient as it can use specialized, smaller models for planning and solving, and it can handle more complex tasks by breaking them down into subtasks. However, challenges such as calculation errors and semantic misunderstandings can arise. Despite these issues, these strategies are valuable for improving the reasoning capabilities of LLMs and their effectiveness in problem-solving tasks.

== 5. Building a Chatbot like ChatGPT

[NOTE]
====
Example::
generative_ai_with_langchain/chat_with_retrieval/app.py
====

Retrieval-augmented generation (RAG) is a method used to improve text generation by incorporating external knowledge into language models, referred to as Retrieval-Augmented Language Models (RALMs). Unlike traditional language models that rely solely on a given prompt, RALMs use semantic search algorithms to find and use relevant information from external sources to create more accurate and contextually appropriate text. This process involves dynamically querying and retrieving data to inform the generation process, which can lead to more nuanced, factually correct, and useful outputs. The technique relies on efficient storage and indexing of vector embeddings to perform real-time semantic searches across vast document collections. By leveraging RAG, language models can reduce incorrect or irrelevant responses, especially in specialized fields like healthcare. Vector search, a related concept, involves retrieving vectors based on similarity to enhance various applications including search engines and chatbots.

---

Embeddings are numerical vectors that represent objects like words, sentences, or images in a format that machines can understand, capturing their semantic content. In OpenAI LLM an embedding consists of 1,536 numbers that encapsulate the text's meaning. Word embeddings can be visualized in a vector space where semantic similarity corresponds to proximity. Traditional methods like the *bag-of-words* have been succeeded by more advanced models like *word2vec*, which learn embeddings from word context. For images, embeddings can be derived from convolutional neural networks.

Embeddings are used for a variety of machine learning tasks, such as measuring similarity, classification, or as input for other models. In LangChain, embeddings can be obtained using methods like `embed_query()` for single inputs or `embed_documents()` for multiple inputs. Arithmetic operations can be performed on embeddings, like calculating distances to analyze similarity.

The text also discusses how to generate and analyze embeddings using LangChain and Python code, including visualizing distances between word embeddings to confirm their semantic relationships. Additionally, LangChain offers tools for integrating embeddings into apps and systems, as well as a `FakeEmbeddings` class for testing without external calls.

---

Vector search is a technique used to find similar data points in a high-dimensional space by representing data as vectors and measuring the similarity between them. This method is useful in applications such as recommendation systems and image or text search. Data points are organized through indexing, using algorithms such as k-d trees, Annoy, and product quantization for efficient retrieval.

Vector libraries, like Faiss and Annoy, offer functions for indexing and searching vectors, with some libraries being more popular than others based on GitHub stars. Vector databases like Milvus and Pinecone provide a comprehensive solution for managing and querying vector embeddings, supporting a variety of use cases such as anomaly detection, personalization, and natural language processing.

The market for vector databases is growing, with open-source options being popular for their AI and data management capabilities. They are designed for specific tasks such as similarity search and can handle high-dimensional data efficiently. Examples of vector databases include Chroma, Qdrant, and Milvus, among others, each with its unique features, business models, indexing methods, and licensing.

LangChain's `vectorstores` module can be used to implement vector storage, with Chroma as an example backend optimized for storing and querying vectors. To use Chroma, one must import the necessary modules, create an instance with documents and an embedding method, and then query the vector store to find similar vectors. Document loaders and retrievers are also important components when building applications like chatbots.

---

LangChain provides a toolchain for creating retrieval systems, including a pipeline for building a chatbot with Retrieval-Augmented Generation (RAG). The process involves data loaders to import documents, document transformers to process them, embedding models to convert text to vector representations, vector stores to maintain these embeddings, and retrievers to fetch relevant information based on queries.

Data loaders help load documents from various sources, such as text files, web pages, Arxiv, or YouTube, into the LangChain framework as Document objects with text and metadata. Examples of different loaders include `TextLoader`, `WebBaseLoader`, `ArxivLoader`, `YoutubeLoader`, and `ImageCaptionLoader`. These loaders can fetch documents either eagerly or lazily as needed.

Retrievers are components used to search and retrieve information from a vector store, where document embeddings are indexed. Different types of retrievers are available, such as BM25, TF-IDF, dense, and kNN retrievers, each with its own strengths and use cases. Specialized retrievers, like the `ArxivRetriever` and `WikipediaRetriever`, cater to specific domains like scientific literature and Wikipedia respectively.

Examples are provided for using a kNN retriever with OpenAI embeddings to retrieve documents based on text similarity, and a PubMed retriever to fetch biomedical literature relevant to queries like "COVID."

Additionally, custom retrievers can be created by inheriting from the `BaseRetriever` class and implementing the `get_relevant_documents()` method to define the retrieval logic for any specific requirements.

In summary, LangChain helps build chatbots and other retrieval systems by offering tools to load, transform, embed, store, and retrieve documents, with flexibility to handle various data sources and to customize retrievers as per the application's needs.

---

The provided content outlines how to implement a simple chatbot using the LangChain framework. The process involves setting up a document loader to read various document formats (PDF, text, EPUB, Word), storing documents in a vector store, and configuring a chatbot to retrieve information from the vector storage.

The document loader is designed to support multiple file extensions and load files as a list of documents, while the vector storage is configured using a Hugging Face model for embeddings and DocArray for in-memory storage. The retriever employs maximum marginal relevance (MMR) to retrieve diverse and relevant documents.

Contextual compression techniques are mentioned to enhance retrieval by filtering out irrelevant information, with options like LLMChainExtractor, LLMChainFilter, and EmbeddingsFilter. The chatbot chain is set up with memory for contextual conversation and a ChatOpenAI model.

The interface for the chatbot is created using Streamlit, allowing users to upload documents and interact with the chatbot. However, limitations such as input size, cost, and complexity of in-house model hosting are acknowledged, with further discussion to be found in a later chapter on customizing language models.

---

Memory is crucial for chatbots to have coherent conversations by remembering previous interactions. It provides context, personalization, and the ability to learn from past exchanges. LangChain's `ConversationBufferMemory` and `ConversationBufferWindowMemory` are examples of how to implement memory in chatbots. `ConversationBufferMemory` stores all messages, while `ConversationBufferWindowMemory` keeps only a specified number of recent interactions.

Customization of conversational memory is possible by changing prefixes and templates in LangChain. `ConversationSummaryMemory` provides a condensed version of conversation history, and `ConversationKGMemory` enables storing facts in a knowledge graph format. Multiple memory strategies can be combined with `CombinedMemory`.

`ConversationSummaryBufferMemory` summarizes old interactions and keeps recent ones to manage token limits. Long-term persistence can be achieved using platforms like Zep, which offer persistent backends for storing, summarizing, and searching chat histories. This enhances AI capabilities and context awareness. 

---

Moderation in chatbots is crucial for ensuring interactions are appropriate and respectful, aligning with ethical standards, and protecting users from offensive content. A "constitution" for chatbots establishes guidelines for their behavior, promoting ethical engagement and safeguarding brand reputation. This framework also helps in meeting legal requirements for content moderation. 

To implement moderation, developers can use pre-built moderation chains such as the `OpenAIModerationChain` in LangChain, which can be appended to the chatbot's operational chain. If harmful content is detected, the system can either throw an error or inform the user that the content is unacceptable.

Guardrails are additional controls that provide programmable constraints to guide the chatbot's output, preventing discussions on sensitive topics, ensuring conversations follow predefined paths, maintaining a specific language style, and extracting structured data from interactions. These measures ensure that chatbots operate within safe and desired parameters, maintaining user trust and compliance with standards.

== 6. Developing Software with Generative AI

[NOTE]
====
Example::
generative_ai_with_langchain/software_development/baby_dev.py
====

== 7. LLMs for Data Science

MLJAR Automated Machine Learning for Humans::
https://github.com/mljar/mljar-supervised

Jupyter AI::
https://github.com/jupyterlab/jupyter-ai

Building a Streamlit and scikit-learn app with ChatGPT::
https://blog.streamlit.io/building-a-streamlit-and-scikit-learn-app-with-chatgpt/

=== 7.1. The impact of generative models on data science

Generative AI and LLMs like GPT-4 are significantly impacting data science by automating analysis, democratizing AI, and enhancing research productivity. These tools enable natural language interactions, code generation, and automated report generation, making data science more accessible to those without technical expertise. They help in data exploration, pattern recognition, and synthetic data generation, as well as in literature reviews and identifying research gaps.

AI is leading to democratization, allowing more people to use AI, increasing productivity, and enabling innovation by generating new insights. It is also disrupting industries, though challenges like accuracy, bias, and governance remain. Data science skills are shifting towards governance, ethics, and overseeing AI systems.

However, these models are not infallible and require critical evaluation for accuracy and bias. Microsoft's Fabric, using generative AI, exemplifies the practical application of these technologies in analytics, but underscores the need for expert validation, particularly when used by non-technical users. The advancements in AI are promising but require responsible usage and oversight.

=== 7.2. Automated data science

Data science is an interdisciplinary field that utilizes computer science, statistics, and business analytics to extract insights from data. Data scientists perform various tasks, including data collection, cleaning, analysis, visualization, and predictive modeling. Automation in data science can improve productivity by reducing time-consuming tasks and allowing data scientists to focus on more complex problem-solving.

Automated tools and platforms, such as KNIME, H2O, and RapidMiner, are integrated with language models like GitHub Copilot and Jupyter AI to facilitate code generation for data tasks. Jupyter AI, for example, offers a chat feature that assists data scientists in creating and modifying code.

The book chapter discusses the automation of several data science processes, such as:

- Data collection: Automating the ETL process with tools like AWS Glue, Google Dataflow, and open-source options such as Airflow. LangChain integrates with Zapier for data collection from different sources.
- Visualization and EDA: Automated tools and algorithms analyze and visualize data with minimal manual intervention, and generative AI can create new visualizations based on prompts.
- Preprocessing and feature extraction: LLMs automate tasks like data cleaning and transformation, improving efficiency but posing challenges for safety and interpretability.
- AutoML: Frameworks automate the machine learning process, including data cleaning, feature selection, model training, and hyperparameter tuning. They facilitate rapid model development and deployment, with newer versions also handling neural architecture search and various data types.

Despite the benefits, automated systems like AutoML can be "black-boxes", making it difficult to understand their inner workings and debug problems. Additionally, there is a focus on ensuring privacy and safety in automated processes.

Generative AI can significantly accelerate data science workflows, reduce manual labor, and democratize data science, allowing non-experts to perform expert-level tasks. The chapter emphasizes the potential of generative AI in enhancing the efficiency of data science tasks.

=== 7.3. Using agents to answer data science questions

Tools like `LLMMathChain` can execute Python code to solve computational queries, such as calculating mathematical powers. Similarly, `PythonREPLTool` can be used to create and train simple neural network models on synthetic data and make predictions. These tools can be integrated with language models to perform tasks like training a neural network and providing verbose output of the training process.

Additionally, language models can be enhanced with external tools like WolframAlpha for data enrichment tasks, such as calculating the distance between cities. For instance, calculating the distance from various cities to Tokyo can be done by combining language models with WolframAlpha's capabilities.

While these tools and integrations demonstrate useful applications, integrating them into more complex, real-world scenarios requires careful consideration of security risks and more sophisticated engineering solutions. Overall, chaining language models with specialized tools has the potential to enrich datasets and answer structured dataset queries, but scaling these solutions is not trivial.

=== 7.4. Data exploration with LLMs

The text discusses using Large Language Models (LLMs) like ChatGPT for data exploration by asking questions in natural language and obtaining insights into datasets. The Iris dataset is used to demonstrate how to create a pandas DataFrame agent using the LangChain library, which enables the AI to answer questions about the dataset, generate visualizations like barplots and boxplots, and perform statistical tests like the KS-test. The AI can also add new columns to a DataFrame and pinpoint specific data points. Furthermore, the text mentions the PandasAI library, which simplifies interactions with dataframes using natural language, and the capability to use LLMs to generate and autocorrect SQL queries for databases with the SQLDatabaseChain. The main takeaway is that LLMs can significantly enhance data exploration by simplifying the querying process and assisting with a variety of data analysis tasks.

